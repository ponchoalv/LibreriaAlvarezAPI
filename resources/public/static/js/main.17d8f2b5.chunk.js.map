{"version":3,"sources":["constants/sales.ts","actions/salesActions.ts","actions/listPrices.ts","constants/manageLists.ts","components/commons/ActivityAndErrorIndicator.tsx","constants/listPrices.ts","components/NoMatch.tsx","actions/uploadActions.ts","constants/login.ts","actions/loginActions.ts","components/Login/LoginForm.tsx","components/Login.tsx","containers/Login.ts","routes/index.tsx","App.tsx","api/index.ts","reducers/login.ts","reducers/prices.ts","reducers/upload.ts","reducers/sales.ts","reducers/index.ts","configureStore.ts","serviceWorker.ts","index.tsx"],"names":["INIT_FECTCH","SUCCESSFUL_SALES_FETCH","SUCCESSFUL_DATES_FETCH","SELECT_DATE","FAILED_FETCH","ADD_SALE","DELETE_SALE","FetchSales","type","constants","FaildOnFetch","error","LoadFetchedSales","data","LoadFetchedDates","SelectDate","AddSale","monto","username","DeleteSale","fecha","FetchPrices","LoadFetchedPrices","OnSearchTextUpdate","value","UpdateSelectedList","UpdateSelectedDate","LoadFetchedLists","LoadFetchedLastListDate","SUCCESSFUL_LIST_NAME_FETCH","SUCCESSFUL_LAST_DATE_FETCH","INIT_LAST_DATE_FETCH","UPDATE_SELECTED_DATE","INIT_LIST_UPLOAD","LIST_UPLOAD_SUCCESSFUL","START_EDITING","STOP_EDITING","DELETE_LIST","DELETE_LIST_SUCCESSFUL","CLEAR_EDITING_DATE","LIST_TYPE_FETCHED","TOGGLE_NUEVA_PLANILLA","ActivityAndErrorIndicator","this","props","loaded","initAction","loading","className","style","width","height","color","message","children","React","SUCCESSFUL_PRICE_LIST_FETCH","UPDATE_SEARCH_TEXT","UPDATE_SELECTED_LIST","CLEAR_LOADED_STATE","NoMatch","FetchLastDates","UploadList","SuccessfulLoadedList","StartEditing","StopEditing","DeleteList","ListDeletedSuccessfuly","ClearEditingDate","ClearLoadedState","ListTypeFetched","ToggleNuevaPlanilla","REQUEST_LOGIN","LOGIN_SUCCESSFUL","LOGIN_FAILED","LOGOUT","LoginSuccesFul","payload","LoginFailed","LoginForm","onSubmit","event","preventDefault","form","FormData","currentTarget","login","for","name","id","Login","nothing","token","to","connect","loginToken","dispatch","actions","history","createBrowserHistory","SecuredRoutes","Secured","fallback","mapDispatchToProps","logout","exact","path","component","match","App","ApiTemplate","url","a","fetch","headers","Authentication","Accept","response","ok","Error","statusText","json","fetchPrices","date","fetchLastListDate","fetchLastLists","fetchAllLists","fetchAllLoadedDates","fetchAllListType","cargarLista","body","method","requestLogin","eliminarLista","lista","JSON","stringify","cargaVenta","usuario","obtenerVentasPorFecha","obtenerFechasConVentas","eliminarVenta","initialState","loginApi","Cmd","run","args","failActionCreator","successActionCreator","state","action","loop","get","allListOptions","datesLoaded","prices","searchText","selectOptions","selectedDate","selectedList","loadPrices","loadLastListDate","loadListByDate","list","batch","filter","lists","map","row","addingNewDate","allLoadedLists","filteredLists","listTypeOptions","listsDateOptions","nuevaPlanilla","loadAllListNames","loadAllDatesOptions","deleteList","initUpload","fecthListTypes","upload","none","sales","loadSalesByDate","loadDates","addSale","deleteSale","lastDate","rootReducer","combineReducers","enhancedCreateStore","createStore","isLocalhost","Boolean","window","location","hostname","registerValidSW","swUrl","config","navigator","serviceWorker","register","then","registration","onupdatefound","installingWorker","installing","onstatechange","controller","console","log","onUpdate","onSuccess","catch","store","preloadedState","composeEnhancer","__REDUX_DEVTOOLS_EXTENSION_COMPOSE__","compose","createRootReducer","install","applyMiddleware","configureStore","ReactDOM","render","document","getElementById","URL","process","href","origin","addEventListener","contentType","status","indexOf","ready","unregister","reload","checkValidServiceWorker"],"mappings":"qHAAA,gOAAO,IAAMA,EAAc,qBAGdC,EAAyB,iCAGzBC,EAAyB,iCAGzBC,EAAc,sBAGdC,EAAe,iBAGfC,EAAW,mBAGXC,EAAc,uB,gCClB3B,4OAoDO,SAASC,IACd,MAAO,CACLC,KAAMC,KAIH,SAASC,EAAaC,GAC3B,MAAO,CACLA,QACAH,KAAMC,KAIH,SAASG,EAAiBC,GAC/B,MAAO,CACLA,OACAL,KAAMC,KAIH,SAASK,EAAiBD,GAC/B,MAAO,CACLA,OACAL,KAAMC,KAIH,SAASM,EAAWF,GACzB,MAAO,CACLA,OACAL,KAAMC,KAIH,SAASO,EAAQC,EAAeC,GACrC,MAAO,CACLL,KAAM,CACJI,QACAC,YAEFV,KAAMC,KAIH,SAASU,EAAWC,GACzB,MAAO,CACLP,KAAM,CACJO,MAAOA,GAETZ,KAAMC,O,gCCrGV,2SAiEO,SAASY,IACZ,MAAO,CACHb,KAAMC,KAIP,SAASa,EAAkBT,GAC9B,MAAO,CACHA,OACAL,KAAMC,KAKP,SAASC,EAAaC,GACzB,MAAO,CACHA,QACAH,KAAMC,KAIP,SAASc,EAAmBC,GAC/B,MAAO,CACHhB,KAAMC,IACNe,SAID,SAASC,EAAmBD,GAC/B,MAAO,CACHhB,KAAMC,IACNe,SAID,SAASE,EAAmBF,GAC/B,MAAO,CACHhB,KAAMC,IACNe,SAID,SAASG,EAAiBd,GAC7B,MAAO,CACHA,OACAL,KAAMC,KAIP,SAASK,EAAiBD,GAC7B,MAAO,CACHA,OACAL,KAAMC,KAIP,SAASmB,EAAwBf,GACpC,MAAO,CACHA,OACAL,KAAMC,O,+BC5Hd,geAAO,IAGMoB,EAA6B,0CAG7B3B,EAAyB,sCAGzB4B,EAA6B,0CAG7BC,EAAuB,oCAGvB3B,EAAe,sBASf4B,EAAuB,oCAGvBC,EAAmB,gCAGnBC,EAAyB,sCAGzBC,EAAgB,6BAGhBC,EAAe,4BAGfC,EAAc,2BAGdC,EAAyB,sCAGzBC,EAAqB,kCAGrBC,EAAoB,iCAGpBC,EAAwB,sC,mICjCxBC,EAAb,4LAGYC,KAAKC,MAAMC,QACXF,KAAKC,MAAME,eAJvB,+BASQ,OAAIH,KAAKC,MAAMG,QACJ,uBAAKC,UAAU,UAAS,gBAAC,IAAD,CAASC,MAAO,CAAEC,MAAO,QAASC,OAAQ,SAAW3C,KAAK,UAGzFmC,KAAKC,MAAMjC,MACJ,gBAAC,IAAD,CAAOyC,MAAM,UAAb,0BAA8CT,KAAKC,MAAMjC,MAAM0C,QAA/D,KAGJV,KAAKC,MAAMU,aAjB1B,GAA+CC,c,+BClB/C,gUAAO,IAAMvD,EAAc,yBAGdwD,EAA8B,0CAG9B3B,EAA6B,yCAG7B3B,EAAyB,qCAGzB4B,EAA6B,yCAM7B1B,EAAe,qBAGfqD,EAAqB,kCAGrBC,EAAuB,oCAGvB1B,EAAuB,oCAGvB2B,EAAqB,mC,gCC9BlC,WAQiBC,IAND,kBACZ,uBAAKZ,UAAU,UAAf,4C,mECHJ,khBAmGO,SAASa,IACZ,MAAO,CACHrD,KAAMC,KAIP,SAASqD,EAAWjD,GACvB,MAAO,CACHA,OACAL,KAAMC,KAKP,SAASsD,EAAqBlD,GACjC,MAAO,CACHA,OACAL,KAAMC,KAIP,SAASC,EAAaC,GACzB,MAAO,CACHA,QACAH,KAAMC,KAIP,SAASkB,EAAiBd,GAC7B,MAAO,CACHA,OACAL,KAAMC,KAIP,SAASK,EAAiBD,GAC7B,MAAO,CACHA,OACAL,KAAMC,KAIP,SAASmB,EAAwBf,GACpC,MAAO,CACHA,OACAL,KAAMC,KAIP,SAASiB,EAAmBF,GAC/B,MAAO,CACHhB,KAAMC,IACNe,SAID,SAASwC,IACZ,MAAO,CACHxD,KAAMC,KAIP,SAASwD,IACZ,MAAO,CACHzD,KAAMC,KAIP,SAASyD,EAAW1C,GACvB,MAAO,CACHhB,KAAMC,IACNe,SAID,SAAS2C,IACZ,MAAO,CACH3D,KAAMC,KAIP,SAAS2D,IACZ,MAAO,CACH5D,KAAMC,KAIP,SAAS4D,IACZ,MAAO,CACH7D,KAAMmD,KAIP,SAASW,EAAgBzD,GAC5B,MAAO,CACHA,OACAL,KAAMC,KAIP,SAAS8D,IACZ,MAAO,CACH/D,KAAMC,O,+KCzMD+D,EAAgB,4BAGhBC,EAAmB,+BAGnBC,EAAe,2BAGfC,EAAS,qBCqBf,SAASC,EAAe/D,GAC7B,MAAO,CACLgE,QAAShE,EACTL,KAAMC,GAIH,SAASqE,EAAYnE,GAC1B,MAAO,CACLkE,QAASlE,EACTH,KAAMC,G,iOC2BKsE,MAzCf,SAAmBnC,GAOjB,OACE,gBAAC,IAAD,KACE,gBAAC,IAAD,KACE,gBAAC,IAAD,CAAKI,UAAU,4CACb,gBAAC,IAAD,CAAMA,UAAU,kBACd,gBAAC,IAAD,KACE,qDAEF,gBAAC,IAAD,CAAMgC,SAdI,SAACC,GACnBA,EAAMC,iBACN,IAAMC,EAAO,IAAIC,SAASH,EAAMI,eAChCzC,EAAM0C,MAAMH,KAYF,gBAAC,IAAD,KACE,gBAAC,IAAD,KACE,gBAAC,IAAD,CAAOI,IAAI,YAAX,sBACA,gBAAC,IAAD,CAAO/E,KAAK,OAAOgF,KAAK,WAAWC,GAAG,cAExC,gBAAC,IAAD,KACE,gBAAC,IAAD,CAAOF,IAAI,YAAX,kBACA,gBAAC,IAAD,CAAO/E,KAAK,WAAWgF,KAAK,WAAWC,GAAG,eAG9C,gBAAC,IAAD,KACE,gBAAC,IAAD,CAAQrC,MAAM,WAAd,SACC,QAINR,EAAMjC,OACL,gBAAC,IAAD,CAAOyC,MAAM,UAAb,UAA8BR,EAAMjC,MAAM0C,a,QCxBvCqC,E,2MAfHC,QAAsB,a,wEAG1B,OAAIhD,KAAKC,MAAMgD,MACJ,gBAAC,IAAD,CAAUC,GAAG,WAIpB,gBAACnD,EAAA,EAAD,CAA2BI,WAAYH,KAAKgD,QAAS5C,QAASJ,KAAKC,MAAMG,QAASpC,MAAO,KAAMkC,QAAQ,GACnG,gBAAC,EAAD,CAAWlC,MAAOgC,KAAKC,MAAMjC,MAAOoC,QAASJ,KAAKC,MAAMG,QAASuC,MAAO3C,KAAKC,MAAM0C,a,GAX/E/B,aCGLuC,kBAdR,YAAmD,IAAxBR,EAAuB,EAAvBA,MAC9B,MAAO,CACH3E,MAAO2E,EAAM3E,MACboC,QAASuC,EAAMvC,QACf6C,MAAON,EAAMS,aAId,SAA4BC,GAC/B,MAAO,CACHV,MAAO,SAACzE,GAAD,OAAoBmF,EHM5B,SAAsBnF,GAC3B,MAAO,CACLgE,QAAShE,EACTL,KAAMC,GGTkCwF,CAAqBpF,OAIlDiF,CAA6CJ,G,QCXtDQ,EAAUC,cAEVC,EAAgB7C,OAAW,kBAAM,sDACjC8C,GAAU,SAACzD,GAAD,OACd,gBAAC,WAAD,CACE0D,SACE,2BACE,yBACE,4CAKN,gBAACF,EAAkBxD,KAUjB2D,GAAqB,CACzBC,OJUK,WACL,MAAO,CACLhG,KAAMC,KI+BKqF,eAlDS,SAAC,GACvB,MAAO,CACLR,MAFgD,EAAzBA,QAoDzBiB,GAFaT,CAnCA,SAAClD,GAAD,OACb,gBAAC,IAAD,CAAQsD,QAASA,GACf,gBAAC,IAAD,KACE,gBAAC,IAAD,CACEO,OAAO,EACPC,KAAK,IACLC,UAAW,WACT,OAA+B,OAA3B/D,EAAM0C,MAAMS,WACP,gBAAC,EAAD,MAEF,gBAAC,IAAD,CAAUF,GAAG,cAGxB,gBAAC,IAAD,CACEY,OAAK,EACLC,KAAK,gBACLC,UAAW,WAET,OADA/D,EAAM4D,SACC,gBAAC,IAAD,CAAUX,GAAG,SAGxB,gBAAC,IAAD,CACEa,KAAK,SACLC,UAAW,YAA8B,IAA3BC,EAA0B,EAA1BA,MACZ,OAA+B,OAA3BhE,EAAM0C,MAAMS,WACP,gBAAC,EAAD,MAEF,gBAAC,GAAD,CAASa,MAAOA,OAG3B,gBAAC,IAAD,CAAOD,UAAW/C,UCrDTiD,I,uLANP,OACQ,gBAAC,GAAD,U,GAHEtD,c,+DCDHuD,G,kFAAf,WAA8BC,GAA9B,gBAAAC,EAAA,qEACyBC,MAAMF,EAAK,CAChCG,QAAS,CACPC,eAAgB,wBAChBC,OAAQ,mBACR,eAAgB,sBALtB,WACQC,EADR,QAQgBC,GARhB,sBASU,IAAIC,MAAMF,EAASG,YAT7B,uBAWeH,EAASI,OAXxB,kF,sBAcO,SAAeC,GAAtB,mC,+CAAO,WAA2BC,GAA3B,UAAAX,EAAA,qEACQF,GAAyB,8BAAgCa,GADjE,kF,sBAIA,SAAeC,KAAtB,gC,+CAAO,uBAAAZ,EAAA,qEACQF,GAAoB,sBAD5B,kF,sBAIA,SAAee,GAAtB,mC,+CAAO,WAA8BF,GAA9B,UAAAX,EAAA,qEACQU,GAAYC,GADpB,kF,sBAIA,SAASG,KACd,OAAOhB,GAA2B,6BAG7B,SAASiB,KACd,OAAOjB,GAA2B,sBAG7B,SAASkB,KACd,OAAOlB,GAAsB,uBAGxB,SAAemB,GAAtB,mC,+CAAO,WAA2B9C,GAA3B,gBAAA6B,EAAA,qEACkBC,MAAM,oBAAqB,CAChDiB,KAAM/C,EACNgD,OAAQ,SAHL,WACCd,EADD,QAMSC,GANT,sBAOG,IAAIC,MAAMF,EAASG,YAPtB,uBAUQH,EAASI,OAVjB,kF,sBAaA,SAAeW,GAAtB,mC,+CAAO,WAA4BjD,GAA5B,gBAAA6B,EAAA,qEACkBC,MAAM,aAAc,CACzCiB,KAAM/C,EACNgD,OAAQ,SAHL,WACCd,EADD,QAMSC,GANT,sBAOG,IAAIC,MAAMF,EAASG,YAPtB,uBAUQH,EAASI,OAVjB,kF,sBAaA,SAAeY,GAAtB,mC,+CAAO,WAA6BC,GAA7B,gBAAAtB,EAAA,qEACkBC,MAAM,oCAAqC,CAChEiB,KAAMK,KAAKC,UAAUF,GACrBpB,QAAS,CAAE,eAAgB,oBAC3BiB,OAAQ,SAJL,WACCd,EADD,QAOSC,GAPT,sBAQG,IAAIC,MAAMF,EAASG,YARtB,uBAWQH,EAASI,OAXjB,kF,sBAcA,IAAMgB,GAAU,wCAAG,WACxBxH,EACAyH,GAFwB,gBAAA1B,EAAA,qEAIDC,MAAM,iBAAkB,CAC7CiB,KAAMK,KAAKC,UAAU,CACnBvH,QACAyH,YAEFxB,QAAS,CAAE,eAAgB,oBAC3BiB,OAAQ,SAVc,WAIlBd,EAJkB,QAaVC,GAbU,sBAchB,IAAIC,MAAMF,EAASG,YAdH,uBAiBXH,EAASI,OAjBE,iFAAH,wDA8BVkB,GAAqB,wCAAG,WACnCvH,GADmC,gBAAA4F,EAAA,qEAGZC,MAAM,gCAAD,OAAiC7F,IAH1B,WAG7BiG,EAH6B,QAKrBC,GALqB,sBAM3B,IAAIC,MAAMF,EAASG,YANQ,uBAStBH,EAASI,OATa,iFAAH,sDAYrBmB,GAAyB,WACpC,OAAO9B,GAA2B,+BAGvB+B,GAAa,wCAAG,WAAOzH,GAAP,gBAAA4F,EAAA,qEACJC,MAAM,2BAA4B,CACvDiB,KAAMK,KAAKC,UAAU,CACnBpH,UAEF8F,QAAS,CAAE,eAAgB,oBAC3BiB,OAAQ,SANiB,WACrBd,EADqB,QASbC,GATa,sBAUnB,IAAIC,MAAMF,EAASG,YAVA,uBAadH,EAASI,OAbK,iFAAH,sD,wjBC/H1B,IAAMqB,GAA4B,CAChCnI,MAAO,KACPoC,SAAS,EACTgD,WAAY,KACZ7E,SAAU,MAGN6H,GAAoD,SAAClI,GAAD,OACxDmI,KAAIC,IAAIb,GAAc,CACpBc,KAAM,CAACrI,GACPsI,kBAAmBrE,EACnBsE,qBAAsBxE,KAGbU,GAA+C,WAGR,IAFlD+D,EAEiD,uDAF5BP,GACrBQ,EACiD,uCACjD,OAAQA,EAAO9I,MACb,KAAKC,EACH,OAAO8I,aAAK,GAAD,GAEJF,EAFI,CAGP1I,MAAO,KACPoC,SAAS,EACT7B,SAAUoI,EAAOzE,QAAQ2E,IAAI,cAE/BT,GAASO,EAAOzE,UAEpB,KAAKpE,EACH,OAAO,GAAP,GAAW4I,EAAX,CACE1I,MAAO,KACPoC,SAAS,EACTgD,WAAYuD,EAAOzE,UAEvB,KAAKpE,EACH,MAAO,CACLE,MAAO2I,EAAOzE,QACd9B,SAAS,EACTgD,WAAY,KACZ7E,SAAU,MAEd,KAAKT,EACH,OAAOqI,GACT,QACE,OAAOO,I,ykBC3Bb,IAAMP,GAA6B,CAC/BW,eAAgB,GAChBC,YAAa,GACb/I,MAAO,KACPkC,QAAQ,EACRE,SAAS,EACT4G,OAAQ,GACRC,WAAY,GACZC,cAAe,GACfC,aAAc,CAAE1I,MAAO,IACvB2I,aAAc,IAGZC,GACF,SAACrC,GAAD,OAAkBqB,KAAIC,IAAIpB,GAAgB,CACtCqB,KAAM,CAACvB,GACPwB,kBAAmBzI,KACnB0I,qBAAsB9H,QAgBxB2I,GACF,kBAAMjB,KAAIC,IAAIrB,GAAmB,CAC7BuB,kBAAmBzI,KACnB0I,qBAAsBxH,QAGxBsI,GACF,SAACvC,GAAD,OAAkBqB,KAAImB,KAAK,CAACH,GAAWrC,GAlBjCqB,KAAIC,IAAInB,GAAe,CACzBqB,kBAAmBzI,KACnB0I,qBAAsBzH,OAIpBqH,KAAIC,IAAIlB,GAAqB,CAC/BoB,kBAAmBzI,KACnB0I,qBAAsBtI,QAU+C,CACrEsJ,OAAO,KAGFT,GACT,WAAwH,IAAvHN,EAAsH,uDAAhGP,GAAcQ,EAAkF,uCACnH,OAAQA,EAAO9I,MACX,KAAKC,KACD,OAAO8I,aAAK,MACHF,EADE,CAEH1I,MAAO,KACPoC,SAAS,IACbkH,MACR,KAAKxJ,KACD,OAAO,MACA4I,EADP,CAEIxG,QAAQ,EACRE,SAAS,EACT4G,OAAQL,EAAOzI,OAEvB,KAAKJ,KACD,OAAOqI,GACX,KAAKrI,KACD,OAAO,MACA4I,EADP,CAEII,eAAgBH,EAAOzI,KACvBkC,SAAS,EACT8G,cAAeP,EAAOzI,KACjBwJ,OAAO,SAAAC,GAAK,OAAIA,EAAMlJ,QAAUiI,EAAMS,aAAa1I,QACnDmJ,IAAI,SAAAC,GAAG,OAAIA,EAAIlC,UAE5B,KAAK7H,KACD,OAAO8I,aAAK,MACLF,EADI,CAEPS,aAAc,CAAE1I,MAAOkI,EAAOzI,QAC/BqJ,GAAeZ,EAAOzI,OAC7B,KAAKJ,KACD,OAAO,MACA4I,EADP,CAEIK,YAAaJ,EAAOzI,OAE5B,KAAKJ,KACD,OAAO,MAAK4I,EAAZ,CAAmB1I,MAAO2I,EAAO3I,MAAOoC,SAAS,IACrD,KAAKtC,KACD,OAAO,MACA4I,EADP,CAEIO,WAAYN,EAAO9H,QAE3B,KAAKf,KACD,OAAO,MACA4I,EADP,CAEIU,aAAcT,EAAO9H,QAE7B,KAAKf,KACD,OAAO8I,aAAK,MACLF,EADI,CAEPtG,SAAS,EACT8G,cAAeR,EAAMI,eAChBY,OAAO,SAAAC,GAAK,OAAIA,EAAMlJ,QAAUkI,EAAO9H,MAAMJ,QAC7CmJ,IAAI,SAAAC,GAAG,OAAIA,EAAIlC,QACpBwB,aAAcR,EAAO9H,MACrBuI,aAAc,KACfC,GAAWV,EAAO9H,MAAMJ,QAC/B,QAAS,OAAOiI,I,wkBChG5B,IAAMP,GAAmC,CACrC2B,eAAe,EACfC,eAAgB,GAChB/J,MAAO,KACPgK,cAAe,GACfC,gBAAiB,GACjBC,iBAAkB,GAClB9H,SAAS,EACT+H,eAAe,EACfhB,aAAc,CAAE1I,MAAO,KAGrB6I,GACF,kBAAMjB,KAAIC,IAAIrB,GAAmB,CAC7BuB,kBAAmBzI,KACnB0I,qBAAsBxH,QAGxBmJ,GACF,kBAAM/B,KAAIC,IAAInB,GAAe,CACzBqB,kBAAmBzI,KACnB0I,qBAAsBzH,QAGxBqJ,GACF,kBAAMhC,KAAIC,IAAIlB,GAAqB,CAC/BoB,kBAAmBzI,KACnB0I,qBAAsBtI,QAGxBmK,GACF,SAACd,GAAD,OAA2BnB,KAAIC,IAAIZ,GAAe,CAC9Ca,KAAM,CAACiB,GACPhB,kBAAmBzI,KACnB0I,qBAAsBjF,QAGxB+G,GACF,SAACrK,GAAD,OAAoBmI,KAAIC,IAAIhB,GAAa,CACrCiB,KAAM,CAACrI,GACPsI,kBAAmBzI,KACnB0I,qBAAsBrF,QAGxBoH,GACF,kBAAMnC,KAAIC,IAAIjB,GAAkB,CAC5BmB,kBAAmBzI,KACnB0I,qBAAsB9E,QAIjB8G,GACT,WAA0I,IAAzI/B,EAAwI,uDAA5GP,GAAcQ,EAA8F,uCACrI,OAAQA,EAAO9I,MACX,KAAKC,KACD,OAAO8I,aAAK,MAEDF,EAFA,CAGH1I,MAAO,KACPoC,SAAS,IACViG,KAAImB,KACH,CACIF,KACAc,KACAC,KACAG,MACD,CACCf,OAAO,KAGvB,KAAK3J,KACD,OAAO,MACA4I,EADP,CAEIqB,eAAgBpB,EAAOzI,KACvB8J,cAAerB,EAAOzI,KACjBwJ,OAAO,SAAAC,GAAK,OAAIA,EAAMlJ,QAAUiI,EAAMS,aAAa1I,QACxD2B,SAAS,IAEjB,KAAKtC,KACD,OAAO,MACA4I,EADP,CAEIwB,iBAAkBvB,EAAOzI,OAEjC,KAAKJ,KACD,OAAO8I,aAAK,MACLF,EADI,CAEPS,aAAc,CAAE1I,MAAOkI,EAAOzI,QAC/BmI,KAAIM,OAAO5H,aAAmB,CAACN,MAAOkI,EAAOzI,SACpD,KAAKJ,KACD,OAAO,MAAK4I,EAAZ,CAAmB1I,MAAO2I,EAAO3I,MAAOoC,SAAS,IACrD,KAAKtC,KACD,OAAO8I,aAAK,MACLF,EADI,CAEPsB,cAAetB,EAAMqB,eAChBL,OAAO,SAAAC,GAAK,OAAIA,EAAMlJ,QAAUkI,EAAO9H,MAAMJ,QAClD0I,aAAcR,EAAO9H,QACtBwH,KAAIqC,MACX,KAAK5K,KACD,OAAO8I,aAAK,MACLF,EADI,CAEPtG,SAAS,IACVmI,GAAW5B,EAAOzI,OACzB,KAAKJ,KACD,OAAO8I,aAAK,MACLF,EADI,CAEPtG,SAAS,IACViG,KAAImB,KACH,CACIY,KACAC,KACAhC,KAAIM,OAAOjF,gBACX2E,KAAIM,OAAOrF,gBACX+E,KAAIM,OAAO/E,iBACZ,CACC6F,OAAO,KAEnB,KAAK3J,KACD,OAAO,MACA4I,EADP,CAEIoB,eAAe,IAEvB,KAAKhK,KACD,OAAO8I,aAAK,MACLF,EADI,CAEPoB,eAAe,IAChBzB,KAAIqC,MACX,KAAK5K,KACD,OAAO8I,aAAK,MACLF,EADI,CAEPoB,eAAe,IAChBR,MACP,KAAKxJ,KACD,OAAO8I,aAAK,MACLF,EADI,CAEPtG,SAAS,IACVkI,GAAW3B,EAAO9H,QACzB,KAAKf,KACD,OAAO8I,aAAK,MACLF,EADI,CAEPtG,SAAS,IACViG,KAAImB,KACH,CACIY,KACAC,KACAhC,KAAIM,OAAOjF,iBACZ,CACC+F,OAAO,KAEnB,KAAK3J,KACD,OAAO,MACA4I,EADP,CAEIuB,gBAAiBtB,EAAOzI,OAEhC,KAAKJ,KACD,OAAO,MACA4I,EADP,CAEIyB,eAAgBzB,EAAMyB,gBAE9B,QAAS,OAAOzB,I,0kBC7K5B,IAAMP,GAA4B,CAChCY,YAAa,GACb/I,MAAO,KACPkC,QAAQ,EACRE,SAAS,EACTuI,MAAO,GACPxB,aAAc,IAGVyB,GAA0D,SAC9D5D,GAD8D,OAG9DqB,KAAIC,IAAIN,GAAuB,CAC7BO,KAAM,CAACvB,GACPwB,kBAAmBzI,KACnB0I,qBAAsBxI,QAGpB4K,GAAwC,kBAC5CxC,KAAIC,IAAIL,GAAwB,CAC9BO,kBAAmBzI,KACnB0I,qBAAsBtI,QAGpB2K,GAAqE,SACzExK,EACAC,GAFyE,OAIzE8H,KAAIC,IAAIR,GAAY,CAClBS,KAAM,CAACjI,EAAOC,GACdiI,kBAAmBzI,KACnB0I,qBAAsB7I,QAGpBmL,GAAsD,SAACtK,GAAD,OAC1D4H,KAAIC,IAAIJ,GAAe,CACrBK,KAAM,CAAC9H,GACP+H,kBAAmBzI,KACnB0I,qBAAsB7I,QAGb+K,GAAgD,WAGR,IAFnDjC,EAEkD,uDAF1CP,GACRQ,EACkD,uCAClD,OAAQA,EAAO9I,MACb,KAAKC,KACH,OAAO8I,aAAK,MAAKF,EAAN,CAAa1I,MAAO,KAAMoC,SAAS,IAAQyI,MACxD,KAAK/K,KACH,IAAMkL,EAAWrC,EAAOzI,KAAK,GAAKyI,EAAOzI,KAAK,GAAGO,MAAQ,aACzD,OAAOmI,aAAK,MAELF,EAFI,CAGPtG,SAAS,EACT2G,YAAaJ,EAAOzI,KACpBiJ,aAAc6B,IAEhBJ,GAAgBI,IAGpB,KAAKlL,KACH,OAAO,MACF4I,EADL,CAEEiC,MAAOhC,EAAOzI,KACdkC,SAAS,EACTF,QAAQ,IAEZ,KAAKpC,KACH,OAAO8I,aAAK,MAELF,EAFI,CAGPtG,SAAS,IAEX0I,GAAQnC,EAAOzI,KAAKI,MAAOqI,EAAOzI,KAAKK,WAE3C,KAAKT,KACH,OAAO8I,aAAK,MAELF,EAFI,CAGPtG,SAAS,IAEX2I,GAAWpC,EAAOzI,KAAKO,QAE3B,KAAKX,KACH,OAAO,MAAK4I,EAAZ,CAAmB1I,MAAO2I,EAAO3I,MAAOoC,SAAS,IACnD,KAAKtC,KACH,OAAO8I,aAAK,MAELF,EAFI,CAGPtG,SAAS,EACT+G,aAAcR,EAAOzI,OAEvB0K,GAAgBjC,EAAOzI,OAE3B,QACE,OAAOwI,ICpFEuC,GAdK,kBAClBC,aAME,CACAlC,UACAyB,UACA9F,SACAgG,YCrBEQ,GAAsBC,KCQ5B,IAAMC,GAAcC,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASxF,MACvB,2DA8CN,SAASyF,GAAgBC,EAAeC,GACtCC,UAAUC,cACPC,SAASJ,GACTK,KAAK,SAAAC,GACJA,EAAaC,cAAgB,WAC3B,IAAMC,EAAmBF,EAAaG,WACd,MAApBD,IAGJA,EAAiBE,cAAgB,WACA,cAA3BF,EAAiBzD,QACfmD,UAAUC,cAAcQ,YAI1BC,QAAQC,IACN,gHAKEZ,GAAUA,EAAOa,UACnBb,EAAOa,SAASR,KAMlBM,QAAQC,IAAI,sCAGRZ,GAAUA,EAAOc,WACnBd,EAAOc,UAAUT,UAO5BU,MAAM,SAAA3M,GACLuM,QAAQvM,MAAM,4CAA6CA,KCjGjE,IAAM4M,GFDS,SAAwBC,GACrC,IAAMC,EAAmCvB,OAAewB,sCAAwCC,KAYhG,OAVc7B,GACZ8B,KACAJ,EACAC,EACEI,eACAC,iBEPQC,GAEdC,IAASC,OACL,kBAAC,IAAD,CAAUV,MAAOA,IACb,kBAAC,GAAD,OACSW,SAASC,eAAe,SDelC,SAAkB5B,GACvB,GAA6C,kBAAmBC,UAAW,CAMzE,GAJkB,IAAI4B,IACnBC,GACDnC,OAAOC,SAASmC,MAEJC,SAAWrC,OAAOC,SAASoC,OAIvC,OAGFrC,OAAOsC,iBAAiB,OAAQ,WAC9B,IAAMlC,EAAK,UAAM+B,GAAN,sBAEPrC,KAgEV,SAAiCM,EAAeC,GAE9CtF,MAAMqF,GACHK,KAAK,SAAAtF,GAEJ,IAAMoH,EAAcpH,EAASH,QAAQsC,IAAI,gBAEnB,MAApBnC,EAASqH,QACO,MAAfD,IAA8D,IAAvCA,EAAYE,QAAQ,cAG5CnC,UAAUC,cAAcmC,MAAMjC,KAAK,SAAAC,GACjCA,EAAaiC,aAAalC,KAAK,WAC7BT,OAAOC,SAAS2C,aAKpBzC,GAAgBC,EAAOC,KAG1Be,MAAM,WACLJ,QAAQC,IACN,mEArFA4B,CAAwBzC,EAAOC,GAI/BC,UAAUC,cAAcmC,MAAMjC,KAAK,WACjCO,QAAQC,IACN,+GAMJd,GAAgBC,EAAOC,MCzC/BE,K","file":"static/js/main.17d8f2b5.chunk.js","sourcesContent":["export const INIT_FECTCH = \"@@SALES/INIT_FETCH\";\nexport type INIT_FECTCH = typeof INIT_FECTCH;\n\nexport const SUCCESSFUL_SALES_FETCH = \"@@SALES/SUCCESSFUL_SALES_FETCH\";\nexport type SUCCESSFUL_SALES_FETCH = typeof SUCCESSFUL_SALES_FETCH;\n\nexport const SUCCESSFUL_DATES_FETCH = \"@@SALES/SUCCESSFUL_DATES_FETCH\";\nexport type SUCCESSFUL_DATES_FETCH = typeof SUCCESSFUL_DATES_FETCH;\n\nexport const SELECT_DATE = \"@@SALES/SELECT_DATE\";\nexport type SELECT_DATE = typeof SELECT_DATE;\n\nexport const FAILED_FETCH = \"@@SALES/FAILED\";\nexport type FAILED_FETCH = typeof FAILED_FETCH;\n\nexport const ADD_SALE = \"@@SALES/ADD_SALE\";\nexport type ADD_SALE = \"@@SALES/ADD_SALE\";\n\nexport const DELETE_SALE = \"@@SALES/DELETE_SALE\";\nexport type DELETE_SALE = \"@@SALES/DELETE_SALE\";\n","import * as constants from \"../constants/sales\";\nimport { IDateOfList, IVenta } from \"../types\";\n\n// List of prices events\nexport interface InitPriceFetch {\n  type: constants.INIT_FECTCH;\n}\n\nexport interface ISuccessfulDatesFetched {\n  type: constants.SUCCESSFUL_DATES_FETCH;\n  data: IDateOfList[];\n}\n\nexport interface IFailOnFetch {\n  type: constants.FAILED_FETCH;\n  error: Error;\n}\n\nexport interface ISuccessfulSalesFetched {\n  type: constants.SUCCESSFUL_SALES_FETCH;\n  data: IVenta[];\n}\n\nexport interface IUpdateSelectedDate {\n  type: constants.SELECT_DATE;\n  data: string;\n}\n\nexport interface IAddSale {\n  type: constants.ADD_SALE;\n  data: {\n    monto: number;\n    username: string;\n  };\n}\n\nexport interface IDeleteSale {\n  type: constants.DELETE_SALE;\n  data: {\n    fecha: string;\n  };\n}\n\nexport type SalesActions =\n  | InitPriceFetch\n  | IFailOnFetch\n  | ISuccessfulDatesFetched\n  | IUpdateSelectedDate\n  | ISuccessfulSalesFetched\n  | IDeleteSale\n  | IAddSale;\n\nexport function FetchSales(): SalesActions {\n  return {\n    type: constants.INIT_FECTCH\n  };\n}\n\nexport function FaildOnFetch(error: Error): SalesActions {\n  return {\n    error,\n    type: constants.FAILED_FETCH\n  };\n}\n\nexport function LoadFetchedSales(data: IVenta[]): SalesActions {\n  return {\n    data,\n    type: constants.SUCCESSFUL_SALES_FETCH\n  };\n}\n\nexport function LoadFetchedDates(data: IDateOfList[]): SalesActions {\n  return {\n    data,\n    type: constants.SUCCESSFUL_DATES_FETCH\n  };\n}\n\nexport function SelectDate(data: string): SalesActions {\n  return {\n    data,\n    type: constants.SELECT_DATE\n  };\n}\n\nexport function AddSale(monto: number, username: string): SalesActions {\n  return {\n    data: {\n      monto,\n      username\n    },\n    type: constants.ADD_SALE\n  };\n}\n\nexport function DeleteSale(fecha: string): SalesActions {\n  return {\n    data: {\n      fecha: fecha\n    },\n    type: constants.DELETE_SALE\n  };\n}\n","import * as constants from '../constants/listPrices';\nimport { IDateOfList, ILoadedList, IPriceRow } from '../types';\n\n// List of prices events\nexport interface InitPriceFetch {\n    type: constants.INIT_FECTCH;\n}\n\nexport interface ISuccessfulPriceFetched {\n    type: constants.SUCCESSFUL_PRICE_LIST_FETCH;\n    data: IPriceRow[];\n}\n\nexport interface IFailOnFetch {\n    type: constants.FAILED_FETCH;\n    error: Error;\n}\n\nexport interface IUpdateSearchText {\n    type: constants.UPDATE_SEARCH_TEXT;\n    value: string;\n}\n\nexport interface ISuccessfulListsFectched {\n    type: constants.SUCCESSFUL_LIST_NAME_FETCH;\n    data: ILoadedList[];\n}\n\nexport interface IUpdateSelectedList {\n    type: constants.UPDATE_SELECTED_LIST;\n    value: string;\n}\n\nexport interface IUpdateSelectedDate {\n    type: constants.UPDATE_SELECTED_DATE;\n    value: IDateOfList;\n}\n\nexport interface ISuccessfulDatesFetched {\n    type: constants.SUCCESSFUL_DATES_FETCH;\n    data: IDateOfList[];\n}\n\nexport interface ISuccessfulLastListDateFetched {\n    type: constants.SUCCESSFUL_LAST_DATE_FETCH;\n    data: string;\n}\n\nexport interface IClearLoadedState {\n    type: constants.CLEAR_LOADED_STATE;\n}\n\nexport type PriceFetchAction = \n    | InitPriceFetch \n    | IClearLoadedState\n    | ISuccessfulPriceFetched \n    | IFailOnFetch \n    | IUpdateSearchText \n    | ISuccessfulListsFectched\n    | IUpdateSelectedList\n    | ISuccessfulDatesFetched\n    | ISuccessfulLastListDateFetched\n    | IUpdateSelectedDate;\n\n\nexport function FetchPrices(): PriceFetchAction {\n    return {\n        type: constants.INIT_FECTCH\n    }\n}\n\nexport function LoadFetchedPrices(data: IPriceRow[]): PriceFetchAction {\n    return {\n        data,\n        type: constants.SUCCESSFUL_PRICE_LIST_FETCH,\n        \n    }\n}\n\nexport function FaildOnFetch(error: Error): PriceFetchAction {\n    return {\n        error,\n        type: constants.FAILED_FETCH,\n    }\n}\n\nexport function OnSearchTextUpdate(value: string): PriceFetchAction {\n    return {\n        type: constants.UPDATE_SEARCH_TEXT,\n        value,\n    }\n}\n\nexport function UpdateSelectedList(value: string) : PriceFetchAction {\n    return {\n        type: constants.UPDATE_SELECTED_LIST,\n        value,\n    }\n}\n\nexport function UpdateSelectedDate(value: IDateOfList) : PriceFetchAction {\n    return {\n        type: constants.UPDATE_SELECTED_DATE,\n        value,\n    }\n}\n\nexport function LoadFetchedLists(data: ILoadedList[]) : PriceFetchAction {\n    return {\n        data,\n        type: constants.SUCCESSFUL_LIST_NAME_FETCH,\n    }\n}\n\nexport function LoadFetchedDates(data: IDateOfList[]) : PriceFetchAction {\n    return {\n        data,\n        type: constants.SUCCESSFUL_DATES_FETCH,\n    }\n}\n\nexport function LoadFetchedLastListDate(data:string) : PriceFetchAction {\n    return {\n        data,\n        type: constants.SUCCESSFUL_LAST_DATE_FETCH,\n    }\n}","export const SUCCESSFUL_PRICE_LIST_FETCH = '@@MANAGE_API/SUCCESSFUL_PRICE_LIST_FETCH';\nexport type SUCCESSFUL_PRICE_LIST_FETCH = typeof SUCCESSFUL_PRICE_LIST_FETCH;\n\nexport const SUCCESSFUL_LIST_NAME_FETCH = '@@MANAGE_API/SUCCESSFUL_LIST_NAME_FETCH';\nexport type SUCCESSFUL_LIST_NAME_FETCH = typeof SUCCESSFUL_LIST_NAME_FETCH;\n\nexport const SUCCESSFUL_DATES_FETCH = '@@MANAGE_API/SUCCESSFUL_DATES_FETCH';\nexport type SUCCESSFUL_DATES_FETCH = typeof SUCCESSFUL_DATES_FETCH;\n\nexport const SUCCESSFUL_LAST_DATE_FETCH = '@@MANAGE_API/SUCCESSFUL_LAST_DATE_FETCH';\nexport type SUCCESSFUL_LAST_DATE_FETCH = typeof SUCCESSFUL_LAST_DATE_FETCH;\n\nexport const INIT_LAST_DATE_FETCH = '@@MANAGE_API/INIT_LAST_DATE_FETCH';\nexport type INIT_LAST_DATE_FETCH = typeof INIT_LAST_DATE_FETCH;\n\nexport const FAILED_FETCH = '@@MANAGE_API/FAILED';\nexport type FAILED_FETCH = typeof FAILED_FETCH;\n\nexport const UPDATE_SEARCH_TEXT = '@@MANAGE_API/UPDATE_SEARCH_TEXT';\nexport type UPDATE_SEARCH_TEXT = typeof UPDATE_SEARCH_TEXT;\n\nexport const UPDATE_SELECTED_LIST = '@@MANAGE_API/UPDATE_SELECTED_LIST';\nexport type UPDATE_SELECTED_LIST = typeof UPDATE_SELECTED_LIST;\n\nexport const UPDATE_SELECTED_DATE = '@@MANAGE_API/UPDATE_SELECTED_DATE';\nexport type UPDATE_SELECTED_DATE = typeof UPDATE_SELECTED_DATE;\n\nexport const INIT_LIST_UPLOAD = '@@MANAGE_API/INIT_LIST_UPLOAD';\nexport type INIT_LIST_UPLOAD = typeof INIT_LIST_UPLOAD;\n\nexport const LIST_UPLOAD_SUCCESSFUL = '@@MANAGE_API/LIST_UPLOAD_SUCCESSFUL';\nexport type LIST_UPLOAD_SUCCESSFUL = typeof LIST_UPLOAD_SUCCESSFUL;\n\nexport const START_EDITING = '@@MANAGE_API/START_EDITING';\nexport type START_EDITING = typeof START_EDITING;\n\nexport const STOP_EDITING = '@@MANAGE_API/STOP_EDITING';\nexport type STOP_EDITING = typeof STOP_EDITING;\n\nexport const DELETE_LIST = '@@MANAGE_API/DELETE_LIST';\nexport type DELETE_LIST = typeof DELETE_LIST;\n\nexport const DELETE_LIST_SUCCESSFUL = '@@MANAGE_API/DELETE_LIST_SUCCESSFUL';\nexport type DELETE_LIST_SUCCESSFUL = typeof DELETE_LIST_SUCCESSFUL;\n\nexport const CLEAR_EDITING_DATE = '@@MANAGE_API/CLEAR_EDITING_DATE';\nexport type CLEAR_EDITING_DATE = typeof CLEAR_EDITING_DATE;\n\nexport const LIST_TYPE_FETCHED = '@@MANAGE_API/LIST_TYPE_FETCHED';\nexport type LIST_TYPE_FETCHED = typeof LIST_TYPE_FETCHED;\n\nexport const TOGGLE_NUEVA_PLANILLA = '@@MANAGE_API/TOGGLE_NUEVA_PLANILLA';\nexport type TOGGLE_NUEVA_PLANILLA = typeof TOGGLE_NUEVA_PLANILLA;","import * as React from 'react';\n// @ts-ignore\nimport { Alert, Spinner } from 'reactstrap';\n\n\ninterface IStateProps {\n    children: React.ReactNode;\n    loading: boolean;\n    error: Error | null;\n    loaded: boolean;\n}\n\ninterface IDispatchProps {\n    initAction: () => void;\n}\n\ntype IProps = IStateProps & IDispatchProps;\n\nexport class ActivityAndErrorIndicator extends React.Component<IProps> {\n    \n    componentDidMount() {\n        if(!this.props.loaded) {\n            this.props.initAction();\n        }\n    }\n\n    public render() {\n        if (this.props.loading) {\n            return <div className=\"loader\"><Spinner style={{ width: '30rem', height: '30rem' }} type=\"grow\" /></div>\n        }\n\n        if (this.props.error) {\n            return <Alert color=\"danger\"> Ha Ocurrido un error: {this.props.error.message} </Alert>\n        }\n\n        return this.props.children\n    }\n}","export const INIT_FECTCH = '@@PRICE_API/INIT_FETCH';\nexport type INIT_FECTCH = typeof INIT_FECTCH;\n\nexport const SUCCESSFUL_PRICE_LIST_FETCH = '@@PRICE_API/SUCCESSFUL_PRICE_LIST_FETCH';\nexport type SUCCESSFUL_PRICE_LIST_FETCH = typeof SUCCESSFUL_PRICE_LIST_FETCH;\n\nexport const SUCCESSFUL_LIST_NAME_FETCH = '@@PRICE_API/SUCCESSFUL_LIST_NAME_FETCH';\nexport type SUCCESSFUL_LIST_NAME_FETCH = typeof SUCCESSFUL_LIST_NAME_FETCH;\n\nexport const SUCCESSFUL_DATES_FETCH = '@@PRICE_API/SUCCESSFUL_DATES_FETCH';\nexport type SUCCESSFUL_DATES_FETCH = typeof SUCCESSFUL_DATES_FETCH;\n\nexport const SUCCESSFUL_LAST_DATE_FETCH = '@@PRICE_API/SUCCESSFUL_LAST_DATE_FETCH';\nexport type SUCCESSFUL_LAST_DATE_FETCH = typeof SUCCESSFUL_LAST_DATE_FETCH;\n\nexport const INIT_LAST_DATE_FETCH = '@@PRICE_API/INIT_LAST_DATE_FETCH';\nexport type INIT_LAST_DATE_FETCH = typeof INIT_LAST_DATE_FETCH;\n\nexport const FAILED_FETCH = '@@PRICE_API/FAILED';\nexport type FAILED_FETCH = typeof FAILED_FETCH;\n\nexport const UPDATE_SEARCH_TEXT = '@@PRICE_LIST/UPDATE_SEARCH_TEXT';\nexport type UPDATE_SEARCH_TEXT = typeof UPDATE_SEARCH_TEXT;\n\nexport const UPDATE_SELECTED_LIST = '@@PRICE_LIST/UPDATE_SELECTED_LIST';\nexport type UPDATE_SELECTED_LIST = typeof UPDATE_SELECTED_LIST;\n\nexport const UPDATE_SELECTED_DATE = '@@PRICE_LIST/UPDATE_SELECTED_DATE';\nexport type UPDATE_SELECTED_DATE = typeof UPDATE_SELECTED_DATE;\n\nexport const CLEAR_LOADED_STATE = '@@PRICE_LIST/CLEAR_LOADED_STATE';\nexport type CLEAR_LOADED_STATE = typeof CLEAR_LOADED_STATE;","import * as React from 'react'\n\nconst NoMatch = () => (\n    <div className=\"loader\">\n      La Pagina que estas buscando no existe\n    </div>\n  )\n  \n  export default NoMatch","import { CLEAR_LOADED_STATE } from \"../constants/listPrices\";\nimport * as constants from '../constants/manageLists';\n\n\nimport {\n    IDateOfList,\n    IDeleteListData,\n    ILoadedList,\n    ILoadList\n    } from '../types/index';\n\nexport interface InitLastDateFetch {\n    type: constants.INIT_LAST_DATE_FETCH;\n}\nexport interface IFailOnFetch {\n    type: constants.FAILED_FETCH;\n    error: Error;\n}\nexport interface ISuccessfulListsFectched {\n    type: constants.SUCCESSFUL_LIST_NAME_FETCH;\n    data: ILoadedList[];\n}\nexport interface IUpdateSelectedDate {\n    type: constants.UPDATE_SELECTED_DATE;\n    value: IDateOfList;\n}\n\nexport interface ISuccessfulDatesFetched {\n    type: constants.SUCCESSFUL_DATES_FETCH;\n    data: IDateOfList[];\n}\n\nexport interface ISuccessfulLastListDateFetched {\n    type: constants.SUCCESSFUL_LAST_DATE_FETCH;\n    data: string;\n}\n\nexport interface InitListUpload {\n    type: constants.INIT_LIST_UPLOAD;\n    data: FormData;\n}\n\nexport interface ISuccessfulListUpload {\n    type: constants.LIST_UPLOAD_SUCCESSFUL;\n    data: ILoadList\n}\n\nexport interface IStartEditing {\n    type: constants.START_EDITING;\n}\n\nexport interface IStopEditing {\n    type: constants.STOP_EDITING;\n}\n\nexport interface IDeleteList {\n    type: constants.DELETE_LIST;\n    value: IDeleteListData;\n}\n\nexport interface IListDeletedSuccessfuly {\n    type: constants.DELETE_LIST_SUCCESSFUL;\n}\n\nexport interface IClearEditingDate {\n    type: constants.CLEAR_EDITING_DATE;\n}\n\nexport interface IClearLoadedState {\n    type: CLEAR_LOADED_STATE;\n}\n\nexport interface IListTypeFetched {\n    data: string[];\n    type: constants.LIST_TYPE_FETCHED;\n}\n\nexport interface IToggleNuevaPlanilla {\n    type: constants.TOGGLE_NUEVA_PLANILLA;\n}\n\nexport type UploadListAction = \n    | InitLastDateFetch\n    | IClearLoadedState\n    | ISuccessfulLastListDateFetched\n    | IFailOnFetch\n    | IUpdateSelectedDate\n    | ISuccessfulListsFectched\n    | ISuccessfulDatesFetched\n    | InitListUpload\n    | ISuccessfulListUpload\n    | IStartEditing\n    | IStopEditing\n    | IDeleteList\n    | IListDeletedSuccessfuly\n    | IClearEditingDate\n    | IListTypeFetched\n    | IToggleNuevaPlanilla;\n\nexport function FetchLastDates (): UploadListAction {\n    return {\n        type: constants.INIT_LAST_DATE_FETCH\n    }\n}\n\nexport function UploadList(data: FormData): UploadListAction {\n    return {\n        data,\n        type: constants.INIT_LIST_UPLOAD,\n        \n    }\n}\n\nexport function SuccessfulLoadedList(data: ILoadList): UploadListAction {\n    return {\n        data,\n        type: constants.LIST_UPLOAD_SUCCESSFUL,\n    }\n}\n\nexport function FaildOnFetch(error: Error): UploadListAction {\n    return {\n        error,\n        type: constants.FAILED_FETCH,\n    }\n}\n\nexport function LoadFetchedLists(data: ILoadedList[]): UploadListAction {\n    return {\n        data,\n        type: constants.SUCCESSFUL_LIST_NAME_FETCH,   \n    }\n}\n\nexport function LoadFetchedDates(data: IDateOfList[]): UploadListAction {\n    return {\n        data,\n        type: constants.SUCCESSFUL_DATES_FETCH,\n    }\n}\n\nexport function LoadFetchedLastListDate(data:string): UploadListAction {\n    return {\n        data,\n        type: constants.SUCCESSFUL_LAST_DATE_FETCH,\n    }\n}\n\nexport function UpdateSelectedDate(value: IDateOfList) : UploadListAction {\n    return {\n        type: constants.UPDATE_SELECTED_DATE,\n        value,\n    }\n}\n\nexport function StartEditing() : UploadListAction {\n    return {\n        type: constants.START_EDITING\n    }\n}\n\nexport function StopEditing() : UploadListAction {\n    return {\n        type: constants.STOP_EDITING\n    }\n}\n\nexport function DeleteList(value: IDeleteListData) : UploadListAction {\n    return {\n        type: constants.DELETE_LIST,\n        value\n    }\n}\n\nexport function ListDeletedSuccessfuly() : UploadListAction {\n    return {\n        type: constants.DELETE_LIST_SUCCESSFUL,\n    }\n}\n\nexport function ClearEditingDate() : UploadListAction {\n    return {\n        type: constants.CLEAR_EDITING_DATE,\n    }\n}\n\nexport function ClearLoadedState() : UploadListAction {\n    return {\n        type: CLEAR_LOADED_STATE,\n    }\n}\n\nexport function ListTypeFetched(data: string[]) : UploadListAction {\n    return {\n        data,\n        type: constants.LIST_TYPE_FETCHED,\n    }\n}\n\nexport function ToggleNuevaPlanilla() : UploadListAction {\n    return {\n        type: constants.TOGGLE_NUEVA_PLANILLA,\n    }\n}\n","export const REQUEST_LOGIN = '@@LOGIN_API/REQUEST_LOGIN';\nexport type REQUEST_LOGIN = typeof REQUEST_LOGIN;\n\nexport const LOGIN_SUCCESSFUL = '@@LOGIN_API/LOGIN_SUCCESSFUL';\nexport type LOGIN_SUCCESSFUL = typeof LOGIN_SUCCESSFUL;\n\nexport const LOGIN_FAILED = '@@LOGIN_API/LOGIN_FAILED';\nexport type LOGIN_FAILED = typeof LOGIN_FAILED;\n\nexport const LOGOUT = '@@LOGIN_API/LOGOUT';\nexport type LOGOUT = typeof LOGOUT;\n\n\n","import * as constants from \"../constants/login\";\n\nimport { IToken } from \"../types/index\";\n\nexport interface IRequestLogin {\n  payload: FormData;\n  type: constants.REQUEST_LOGIN;\n}\nexport interface ILoginSuccessful {\n  payload: IToken;\n  type: constants.LOGIN_SUCCESSFUL;\n}\nexport interface ILoginFailed {\n  payload: Error;\n  type: constants.LOGIN_FAILED;\n}\n\nexport interface ILogout {\n  type: constants.LOGOUT\n}\n\nexport type LoginAction = IRequestLogin | ILoginFailed | ILoginSuccessful | ILogout;\n\nexport function RequestLogin(data: FormData): LoginAction {\n  return {\n    payload: data,\n    type: constants.REQUEST_LOGIN\n  };\n}\n\nexport function LoginSuccesFul(data: IToken): LoginAction {\n  return {\n    payload: data,\n    type: constants.LOGIN_SUCCESSFUL\n  };\n}\n\nexport function LoginFailed(error: Error): LoginAction {\n  return {\n    payload: error,\n    type: constants.LOGIN_FAILED\n  };\n}\n\nexport function Logout(): LoginAction {\n  return {\n    type: constants.LOGOUT\n  }\n}\n","import * as React from \"react\";\nimport Button from \"reactstrap/lib/Button\";\nimport Card from \"reactstrap/lib/Card\";\nimport CardBody from \"reactstrap/lib/CardBody\";\nimport CardFooter from \"reactstrap/lib/CardFooter\";\nimport CardHeader from \"reactstrap/lib/CardHeader\";\nimport Form from \"reactstrap/lib/Form\";\nimport FormGroup from \"reactstrap/lib/FormGroup\";\nimport Input from \"reactstrap/lib/Input\";\nimport Label from \"reactstrap/lib/Label\";\nimport Alert from \"reactstrap/lib/Alert\";\nimport Container from \"reactstrap/lib/Container\";\nimport Row from \"reactstrap/lib/Row\";\nimport Col from \"reactstrap/lib/Col\";\n\ninterface IDataProps {\n  error: Error | null;\n  loading: boolean;\n}\n\ninterface IDispatchProps {\n  login: (form: FormData) => void;\n}\n\ntype IProps = IDataProps & IDispatchProps;\n\nfunction LoginForm(props: IProps) {\n  const loginAction = (event: any) => {\n    event.preventDefault();\n    const form = new FormData(event.currentTarget);\n    props.login(form);\n  };\n\n  return (\n    <Container>\n      <Row>\n        <Col className=\"login col-sm-9 col-md-7 col-lg-5 mx-auto\">\n          <Card className=\"border-primary\">\n            <CardHeader>\n              <h4>Login Libreria Alvarez</h4>\n            </CardHeader>\n            <Form onSubmit={loginAction}>\n              <CardBody>\n                <FormGroup>\n                  <Label for=\"username\">Nombre de Usuario:</Label>\n                  <Input type=\"text\" name=\"username\" id=\"username\" />\n                </FormGroup>\n                <FormGroup>\n                  <Label for=\"password\">Contraseña:</Label>\n                  <Input type=\"password\" name=\"password\" id=\"password\" />\n                </FormGroup>\n              </CardBody>\n              <CardFooter>\n                <Button color=\"primary\">Login</Button>\n                {\"  \"}\n              </CardFooter>\n            </Form>\n          </Card>\n          {props.error && (\n            <Alert color=\"danger\">Error: {props.error.message}</Alert>\n          )}\n        </Col>\n      </Row>\n    </Container>\n  );\n}\n\nexport default LoginForm;\n","import * as React from 'react';\nimport LoginForm from './Login/LoginForm';\nimport { IToken } from '../types';\nimport { Redirect } from 'react-router';\nimport { ActivityAndErrorIndicator } from './commons/ActivityAndErrorIndicator';\n\ninterface IStateProps {\n    loading: boolean;\n    error: Error | null;\n    token: IToken | null;\n}\n\ninterface IDispatchProps {\n    login: (data: FormData) => void;\n}\n\ntype IProps = IStateProps & IDispatchProps;\n\nclass Login extends React.Component<IProps, {}> {\n\n    private nothing: () => void = () => {};\n    \n    public render() {\n        if (this.props.token) {\n            return <Redirect to='/users' />\n        }\n\n        return (\n            <ActivityAndErrorIndicator initAction={this.nothing} loading={this.props.loading} error={null} loaded={true} >\n                <LoginForm error={this.props.error} loading={this.props.loading} login={this.props.login} />\n            </ActivityAndErrorIndicator>\n            );\n    }\n}\n\nexport default Login;","import { connect } from 'react-redux';\nimport { Dispatch } from 'redux';\nimport { LoginAction } from '../actions';\nimport * as actions from '../actions/loginActions';\nimport Login from '../components/Login';\nimport { IStoreState } from '../types';\n\nexport function mapStateToProps({ login } : IStoreState) {\n    return {\n        error: login.error,\n        loading: login.loading,\n        token: login.loginToken,\n    }\n}\n\nexport function mapDispatchToProps(dispatch: Dispatch<LoginAction>) {\n    return {\n        login: (data: FormData) => dispatch(actions.RequestLogin(data)),\n    }\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(Login);\n","import * as React from \"react\";\nimport { Route, Switch, Router } from \"react-router\";\nimport NoMatch from \"../components/NoMatch\";\nimport { IRoutesProps, IStoreState, ILoginState } from \"../types\";\nimport Login from \"../containers/Login\";\nimport { Redirect } from \"react-router-dom\";\nimport { connect } from \"react-redux\";\nimport { createBrowserHistory } from \"history\";\nimport { Logout } from \"../actions/loginActions\";\n\nconst history = createBrowserHistory();\n\nconst SecuredRoutes = React.lazy(() => import(\"./secured\"));\nconst Secured = (props: IRoutesProps) => (\n  <React.Suspense\n    fallback={\n      <div>\n        <p>\n          <em>Cargando...</em>\n        </p>\n      </div>\n    }\n  >\n    <SecuredRoutes {...props} />\n  </React.Suspense>\n);\n\nconst mapStateToProps = ({ login }: IStoreState) => {\n  return {\n    login\n  };\n};\n\nconst mapDispatchToProps = {\n  logout: Logout\n};\n\ninterface IProps {\n  login: ILoginState;\n  logout: () => void;\n}\n\nconst Routes = (props: IProps) => (\n  <Router history={history}>\n    <Switch>\n      <Route\n        exact={true}\n        path=\"/\"\n        component={() => {\n          if (props.login.loginToken === null) {\n            return <Login />;\n          }\n          return <Redirect to=\"/users\" />;\n        }}\n      />\n      <Route\n        exact\n        path=\"/users/logout\"\n        component={() => {\n          props.logout();\n          return <Redirect to=\"/\" />;\n        }}\n      />\n      <Route\n        path=\"/users\"\n        component={({ match }: IRoutesProps) => {\n          if (props.login.loginToken === null) {\n            return <Login />;\n          }\n          return <Secured match={match} />;\n        }}\n      />\n      <Route component={NoMatch} />\n    </Switch>\n  </Router>\n);\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(Routes);\n","import 'bootstrap/dist/css/bootstrap.css';\nimport 'open-iconic/font/css/open-iconic-bootstrap.min.css';\nimport * as React from 'react';\nimport Routes from './routes';\nimport './styles/App.css';\n\n\ninterface IAppProps {\n    history: History;\n}\n\nclass App extends React.Component {\n    public render() {\n        return (\n                <Routes />\n        );\n    }\n}\n\nexport default App;\n","import {\n  IDateOfList,\n  IDeleteListData,\n  ILoadedList,\n  ILoadList,\n  IPriceRow,\n  IToken,\n  IVenta\n} from \"../types\";\n\nasync function ApiTemplate<T>(url: string): Promise<T> {\n  const response = await fetch(url, {\n    headers: {\n      Authentication: \"adasdasfasfsafsafasds\",\n      Accept: \"application/json\",\n      \"Content-Type\": \"application/json\"\n    }\n  });\n  if (!response.ok) {\n    throw new Error(response.statusText);\n  }\n  return await response.json();\n}\n\nexport async function fetchPrices(date: string): Promise<IPriceRow[]> {\n  return await ApiTemplate<IPriceRow[]>(\"/api/prices-by-fecha?fecha=\" + date);\n}\n\nexport async function fetchLastListDate(): Promise<string> {\n  return await ApiTemplate<string>(\"/api/get-last-date\");\n}\n\nexport async function fetchLastLists(date: string): Promise<IPriceRow[]> {\n  return await fetchPrices(date);\n}\n\nexport function fetchAllLists(): Promise<ILoadedList[]> {\n  return ApiTemplate<ILoadedList[]>(\"/api/get-all-loaded-lists\");\n}\n\nexport function fetchAllLoadedDates(): Promise<IDateOfList[]> {\n  return ApiTemplate<IDateOfList[]>(\"/api/get-all-dates\");\n}\n\nexport function fetchAllListType(): Promise<string[]> {\n  return ApiTemplate<string[]>(\"/api/get-list-types\");\n}\n\nexport async function cargarLista(form: FormData): Promise<ILoadList> {\n  const response = await fetch(\"/api/cargar-lista\", {\n    body: form,\n    method: \"POST\"\n  });\n\n  if (!response.ok) {\n    throw new Error(response.statusText);\n  }\n\n  return await response.json();\n}\n\nexport async function requestLogin(form: FormData): Promise<IToken> {\n  const response = await fetch(\"/api/login\", {\n    body: form,\n    method: \"POST\"\n  });\n\n  if (!response.ok) {\n    throw new Error(response.statusText);\n  }\n\n  return await response.json();\n}\n\nexport async function eliminarLista(lista: IDeleteListData): Promise<number> {\n  const response = await fetch(\"/api/delete-list-by-date-and-name\", {\n    body: JSON.stringify(lista),\n    headers: { \"Content-type\": \"application/json\" },\n    method: \"POST\"\n  });\n\n  if (!response.ok) {\n    throw new Error(response.statusText);\n  }\n\n  return await response.json();\n}\n\nexport const cargaVenta = async (\n  monto: number,\n  usuario: string\n): Promise<number> => {\n  const response = await fetch(\"/api/add-venta\", {\n    body: JSON.stringify({\n      monto,\n      usuario\n    }),\n    headers: { \"Content-type\": \"application/json\" },\n    method: \"POST\"\n  });\n\n  if (!response.ok) {\n    throw new Error(response.statusText);\n  }\n\n  return await response.json();\n};\n\nexport const obtenerVentas = async (): Promise<IVenta[]> => {\n  const response = await fetch(\"/api/get-ventas\");\n\n  if (!response.ok) {\n    throw new Error(response.statusText);\n  }\n\n  return await response.json();\n};\n\nexport const obtenerVentasPorFecha = async (\n  fecha: string\n): Promise<IVenta[]> => {\n  const response = await fetch(`/api/get-ventas-by-day?fecha=${fecha}`);\n\n  if (!response.ok) {\n    throw new Error(response.statusText);\n  }\n\n  return await response.json();\n};\n\nexport const obtenerFechasConVentas = (): Promise<IDateOfList[]> => {\n  return ApiTemplate<IDateOfList[]>(\"/api/get-fechas-con-ventas\");\n};\n\nexport const eliminarVenta = async (fecha: string): Promise<Number> => {\n  const response = await fetch(\"/api/remove-sale-by-date\", {\n    body: JSON.stringify({\n      fecha\n    }),\n    headers: { \"Content-type\": \"application/json\" },\n    method: \"POST\"\n  });\n\n  if (!response.ok) {\n    throw new Error(response.statusText);\n  }\n\n  return await response.json();\n}","import { Cmd, loop, Loop, LoopReducer, RunCmd } from \"redux-loop\";\nimport { requestLogin } from \"../api\";\nimport * as constants from \"../constants/login\";\nimport { ILoginState } from \"../types/index\";\nimport { LoginAction } from \"../actions\";\nimport { LoginSuccesFul, LoginFailed } from \"../actions/loginActions\";\n\nconst initialState: ILoginState = {\n  error: null,\n  loading: false,\n  loginToken: null,\n  username: null,\n};\n\nconst loginApi: (data: FormData) => RunCmd<LoginAction> = (data: FormData) =>\n  Cmd.run(requestLogin, {\n    args: [data],\n    failActionCreator: LoginFailed,\n    successActionCreator: LoginSuccesFul\n  });\n\nexport const login: LoopReducer<ILoginState, LoginAction> = (\n  state: ILoginState = initialState,\n  action: LoginAction | any\n): ILoginState | Loop<ILoginState, LoginAction> => {\n  switch (action.type) {\n    case constants.REQUEST_LOGIN:\n      return loop(\n        {\n          ...state,\n          error: null,\n          loading: true,\n          username: action.payload.get('username')\n        },\n        loginApi(action.payload)\n      );\n    case constants.LOGIN_SUCCESSFUL:\n      return {...state,\n        error: null,\n        loading: false,\n        loginToken: action.payload\n      };\n    case constants.LOGIN_FAILED:\n      return {\n        error: action.payload,\n        loading: false,\n        loginToken: null, \n        username: null\n      };\n    case constants.LOGOUT:\n      return initialState;\n    default:\n      return state;\n  }\n};\n","import {\n    Cmd,\n    ListCmd,\n    loop,\n    Loop,\n    LoopReducer,\n    RunCmd\n    } from 'redux-loop';\nimport { PriceFetchAction } from '../actions';\nimport {\n    FaildOnFetch,\n    LoadFetchedDates,\n    LoadFetchedLastListDate,\n    LoadFetchedLists,\n    LoadFetchedPrices\n    } from '../actions/listPrices';\nimport * as constants from '../constants/listPrices';\nimport { IPricesState } from '../types/index';\nimport {\n    fetchAllLists,\n    fetchAllLoadedDates,\n    fetchLastListDate,\n    fetchLastLists\n    } from '../api';\n\nconst initialState: IPricesState = {\n    allListOptions: [],\n    datesLoaded: [], \n    error: null,\n    loaded: false,\n    loading: false,\n    prices: [],\n    searchText: \"\",\n    selectOptions: [],\n    selectedDate: { fecha: \"\" },\n    selectedList: \"\",\n}\n\nconst loadPrices: (date: string) => RunCmd<PriceFetchAction> =\n    (date: string) => Cmd.run(fetchLastLists, {\n        args: [date],\n        failActionCreator: FaildOnFetch,\n        successActionCreator: LoadFetchedPrices,\n\n    });\n\nconst loadLists: () => RunCmd<PriceFetchAction> =\n    () => Cmd.run(fetchAllLists, {\n        failActionCreator: FaildOnFetch,\n        successActionCreator: LoadFetchedLists,\n    });\n\nconst loadDates: () => RunCmd<PriceFetchAction> =\n    () => Cmd.run(fetchAllLoadedDates, {\n        failActionCreator: FaildOnFetch,\n        successActionCreator: LoadFetchedDates,\n    });\n\nconst loadLastListDate: () => RunCmd<PriceFetchAction> =\n    () => Cmd.run(fetchLastListDate, {\n        failActionCreator: FaildOnFetch,\n        successActionCreator: LoadFetchedLastListDate,\n    });\n\nconst loadListByDate: (date: string) => ListCmd<PriceFetchAction> =\n    (date: string) => Cmd.list([loadPrices(date), loadLists(), loadDates()], {\n        batch: true\n    });\n\nexport const prices: LoopReducer<IPricesState, PriceFetchAction> =\n    (state: IPricesState = initialState, action: PriceFetchAction): IPricesState | Loop<IPricesState, PriceFetchAction> => {\n        switch (action.type) {\n            case constants.INIT_FECTCH:\n                return loop(\n                    { ...state, \n                        error: null, \n                        loading: true },\n                    loadLastListDate());\n            case constants.SUCCESSFUL_PRICE_LIST_FETCH:\n                return {\n                    ...state,\n                    loaded: true,\n                    loading: false,\n                    prices: action.data,\n                };\n            case constants.CLEAR_LOADED_STATE:\n                return initialState;\n            case constants.SUCCESSFUL_LIST_NAME_FETCH:\n                return {\n                    ...state,\n                    allListOptions: action.data,\n                    loading: false,\n                    selectOptions: action.data\n                        .filter(lists => lists.fecha === state.selectedDate.fecha)\n                        .map(row => row.lista),\n                };\n            case constants.SUCCESSFUL_LAST_DATE_FETCH:\n                return loop({\n                    ...state,\n                    selectedDate: { fecha: action.data },\n                }, loadListByDate(action.data));\n            case constants.SUCCESSFUL_DATES_FETCH:\n                return {\n                    ...state,\n                    datesLoaded: action.data,\n                };\n            case constants.FAILED_FETCH:\n                return { ...state, error: action.error, loading: false };\n            case constants.UPDATE_SEARCH_TEXT:\n                return {\n                    ...state,\n                    searchText: action.value\n                };\n            case constants.UPDATE_SELECTED_LIST:\n                return {\n                    ...state,\n                    selectedList: action.value\n                };\n            case constants.UPDATE_SELECTED_DATE:\n                return loop({\n                    ...state,\n                    loading: true,\n                    selectOptions: state.allListOptions\n                        .filter(lists => lists.fecha === action.value.fecha)\n                        .map(row => row.lista),\n                    selectedDate: action.value,\n                    selectedList: \"\",\n                }, loadPrices(action.value.fecha))\n            default: return state;\n        }\n    }\n","import {\n    Cmd,\n    loop,\n    Loop,\n    LoopReducer,\n    RunCmd\n    } from 'redux-loop';\nimport {\n    ClearLoadedState,\n    FaildOnFetch,\n    ListDeletedSuccessfuly,\n    ListTypeFetched,\n    LoadFetchedDates,\n    LoadFetchedLastListDate,\n    LoadFetchedLists,\n    StopEditing,\n    SuccessfulLoadedList,\n    ToggleNuevaPlanilla,\n    UpdateSelectedDate,\n    UploadListAction\n    } from '../actions/uploadActions';\nimport {\n    cargarLista,\n    eliminarLista,\n    fetchAllLists,\n    fetchAllListType,\n    fetchAllLoadedDates,\n    fetchLastListDate\n    } from '../api';\nimport * as constants from '../constants/manageLists';\nimport { IDeleteListData, IManageUploadState } from '../types/index';\n\nconst initialState: IManageUploadState = {\n    addingNewDate: false,\n    allLoadedLists: [],\n    error: null,\n    filteredLists: [],\n    listTypeOptions: [],\n    listsDateOptions: [],\n    loading: true,\n    nuevaPlanilla: false,\n    selectedDate: { fecha: \"\" },\n}\n\nconst loadLastListDate: () => RunCmd<UploadListAction> =\n    () => Cmd.run(fetchLastListDate, {\n        failActionCreator: FaildOnFetch,\n        successActionCreator: LoadFetchedLastListDate,\n    });\n\nconst loadAllListNames: () => RunCmd<UploadListAction> =\n    () => Cmd.run(fetchAllLists, {\n        failActionCreator: FaildOnFetch,\n        successActionCreator: LoadFetchedLists,\n    });\n\nconst loadAllDatesOptions: () => RunCmd<UploadListAction> =\n    () => Cmd.run(fetchAllLoadedDates, {\n        failActionCreator: FaildOnFetch,\n        successActionCreator: LoadFetchedDates,\n    });\n\nconst deleteList: (list: IDeleteListData) => RunCmd<UploadListAction> =\n    (list: IDeleteListData) => Cmd.run(eliminarLista, {\n        args: [list],\n        failActionCreator: FaildOnFetch,\n        successActionCreator: ListDeletedSuccessfuly,\n    });\n\nconst initUpload: (data: FormData) => RunCmd<UploadListAction> =\n    (data: FormData) => Cmd.run(cargarLista, {\n        args: [data],\n        failActionCreator: FaildOnFetch,\n        successActionCreator: SuccessfulLoadedList,\n    });\n\nconst fecthListTypes: () => RunCmd<UploadListAction> =\n    () => Cmd.run(fetchAllListType, {\n        failActionCreator: FaildOnFetch,\n        successActionCreator: ListTypeFetched,\n    });\n\n\nexport const upload: LoopReducer<IManageUploadState, UploadListAction> =\n    (state: IManageUploadState = initialState, action: UploadListAction): IManageUploadState | Loop<IManageUploadState, UploadListAction> => {\n        switch (action.type) {\n            case constants.INIT_LAST_DATE_FETCH:\n                return loop(\n                    {\n                        ...state,\n                        error: null ,\n                        loading: true\n                    }, Cmd.list(\n                        [\n                            loadLastListDate(), \n                            loadAllListNames(), \n                            loadAllDatesOptions(), \n                            fecthListTypes()\n                        ], {\n                            batch: true\n                    })\n                );\n            case constants.SUCCESSFUL_LIST_NAME_FETCH:\n                return {\n                    ...state,\n                    allLoadedLists: action.data,\n                    filteredLists: action.data\n                        .filter(lists => lists.fecha === state.selectedDate.fecha),\n                    loading: false\n                };\n            case constants.SUCCESSFUL_DATES_FETCH:\n                return {\n                    ...state,\n                    listsDateOptions: action.data\n                }\n            case constants.SUCCESSFUL_LAST_DATE_FETCH:\n                return loop({\n                    ...state,\n                    selectedDate: { fecha: action.data },\n                }, Cmd.action(UpdateSelectedDate({fecha: action.data})));\n            case constants.FAILED_FETCH:\n                return { ...state, error: action.error, loading: false };\n            case constants.UPDATE_SELECTED_DATE:\n                return loop({\n                    ...state,\n                    filteredLists: state.allLoadedLists\n                        .filter(lists => lists.fecha === action.value.fecha),\n                    selectedDate: action.value,\n                }, Cmd.none)\n            case constants.INIT_LIST_UPLOAD:\n                return loop({\n                    ...state,\n                    loading: true,\n                }, initUpload(action.data));\n            case constants.LIST_UPLOAD_SUCCESSFUL:\n                return loop({\n                    ...state,\n                    loading: false,\n                }, Cmd.list(\n                    [\n                        loadAllListNames(), \n                        loadAllDatesOptions(), \n                        Cmd.action(ClearLoadedState()), \n                        Cmd.action(StopEditing()), \n                        Cmd.action(ToggleNuevaPlanilla())\n                    ], {\n                        batch: true\n                }));\n            case constants.START_EDITING:\n                return {\n                    ...state,\n                    addingNewDate: true,\n                }\n            case constants.STOP_EDITING:\n                return loop({\n                    ...state,\n                    addingNewDate: false,\n                }, Cmd.none)\n            case constants.CLEAR_EDITING_DATE:\n                return loop({\n                    ...state,\n                    addingNewDate: false,\n                }, loadLastListDate())\n            case constants.DELETE_LIST:\n                return loop({\n                    ...state,\n                    loading: true\n                }, deleteList(action.value))\n            case constants.DELETE_LIST_SUCCESSFUL:\n                return loop({\n                    ...state,\n                    loading: false\n                }, Cmd.list(\n                    [\n                        loadAllListNames(), \n                        loadAllDatesOptions(), \n                        Cmd.action(ClearLoadedState())\n                    ], {\n                        batch: true\n                    }));\n            case constants.LIST_TYPE_FETCHED:\n                return {\n                    ...state,\n                    listTypeOptions: action.data,\n                }\n            case constants.TOGGLE_NUEVA_PLANILLA:\n                return {\n                    ...state,\n                    nuevaPlanilla: !state.nuevaPlanilla\n                }\n            default: return state;\n        }\n    }\n","import { Cmd, loop, Loop, LoopReducer, RunCmd } from \"redux-loop\";\nimport { SalesActions } from \"../actions\";\nimport {\n  FaildOnFetch,\n  LoadFetchedDates,\n  LoadFetchedSales,\n  FetchSales\n} from \"../actions/salesActions\";\nimport * as constants from \"../constants/sales\";\nimport { ISalesState } from \"../types/index\";\nimport {\n  obtenerFechasConVentas,\n  obtenerVentasPorFecha,\n  cargaVenta,\n  eliminarVenta\n} from \"../api\";\n\nconst initialState: ISalesState = {\n  datesLoaded: [],\n  error: null,\n  loaded: false,\n  loading: false,\n  sales: [],\n  selectedDate: \"\"\n};\n\nconst loadSalesByDate: (date: string) => RunCmd<SalesActions> = (\n  date: string\n) =>\n  Cmd.run(obtenerVentasPorFecha, {\n    args: [date],\n    failActionCreator: FaildOnFetch,\n    successActionCreator: LoadFetchedSales\n  });\n\nconst loadDates: () => RunCmd<SalesActions> = () =>\n  Cmd.run(obtenerFechasConVentas, {\n    failActionCreator: FaildOnFetch,\n    successActionCreator: LoadFetchedDates\n  });\n\nconst addSale: (monto: number, username: string) => RunCmd<SalesActions> = (\n  monto: number,\n  username: string\n) =>\n  Cmd.run(cargaVenta, {\n    args: [monto, username],\n    failActionCreator: FaildOnFetch,\n    successActionCreator: FetchSales\n  });\n\nconst deleteSale: (fecha: string) => RunCmd<SalesActions> = (fecha: string) =>\n  Cmd.run(eliminarVenta, {\n    args: [fecha],\n    failActionCreator: FaildOnFetch,\n    successActionCreator: FetchSales\n  });\n\nexport const sales: LoopReducer<ISalesState, SalesActions> = (\n  state = initialState,\n  action: SalesActions\n): ISalesState | Loop<ISalesState, SalesActions> => {\n  switch (action.type) {\n    case constants.INIT_FECTCH:\n      return loop({ ...state, error: null, loading: true }, loadDates());\n    case constants.SUCCESSFUL_DATES_FETCH: {\n      const lastDate = action.data[0] ? action.data[0].fecha : \"1990-01-01\";\n      return loop(\n        {\n          ...state,\n          loading: true,\n          datesLoaded: action.data,\n          selectedDate: lastDate\n        },\n        loadSalesByDate(lastDate)\n      );\n    }\n    case constants.SUCCESSFUL_SALES_FETCH:\n      return {\n        ...state,\n        sales: action.data,\n        loading: false,\n        loaded: true\n      };\n    case constants.ADD_SALE:\n      return loop(\n        {\n          ...state,\n          loading: true\n        },\n        addSale(action.data.monto, action.data.username)\n      );\n    case constants.DELETE_SALE:\n      return loop(\n        {\n          ...state,\n          loading: true\n        },\n        deleteSale(action.data.fecha)\n      );\n    case constants.FAILED_FETCH:\n      return { ...state, error: action.error, loading: false };\n    case constants.SELECT_DATE:\n      return loop(\n        {\n          ...state,\n          loading: true,\n          selectedDate: action.data\n        },\n        loadSalesByDate(action.data)\n      );\n    default:\n      return state;\n  }\n};\n","import { combineReducers, LoopReducer } from \"redux-loop\";\nimport { login } from \"./login\";\nimport { PriceFetchAction, UploadListAction, LoginAction, SalesActions } from \"../actions\";\nimport {\n  IManageUploadState,\n  IPricesState,\n  IStoreState,\n  ILoginState,\n  ISalesState\n} from \"../types\";\nimport { prices } from \"./prices\";\nimport { upload } from \"./upload\";\nimport { sales } from \"./sales\";\n\nconst rootReducer = () =>\n  combineReducers<\n    | IStoreState\n    | LoopReducer<IPricesState, PriceFetchAction>\n    | LoopReducer<IManageUploadState, UploadListAction>\n    | LoopReducer<ILoginState, LoginAction>\n    | LoopReducer<ISalesState, SalesActions>\n  >({\n    prices,\n    upload,\n    login,\n    sales\n  });\n\nexport default rootReducer;\n","import { applyMiddleware, compose, createStore } from 'redux';\nimport { install, StoreCreator } from 'redux-loop';\nimport createRootReducer from './reducers';\n\nconst enhancedCreateStore = createStore as StoreCreator;\n\nexport default function configureStore(preloadedState?: any) {\n  const composeEnhancer: typeof compose = (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose\n\n  const store = enhancedCreateStore(\n    createRootReducer(),\n    preloadedState,\n    composeEnhancer(\n      install(), \n      applyMiddleware(\n        \n      ),\n    ),\n  )\n  return store\n}","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\nimport App from './App';\nimport configureStore from './configureStore';\nimport * as serviceWorker from './serviceWorker';\n\nconst store = configureStore();\n\nReactDOM.render(\n    <Provider store={store}>\n        <App />\n    </Provider>, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.register();\n "],"sourceRoot":""}