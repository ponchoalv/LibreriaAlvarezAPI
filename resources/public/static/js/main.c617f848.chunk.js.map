{"version":3,"sources":["actions/listPrices.ts","constants/manageLists.ts","components/commons/ActivityAndErrorIndicator.tsx","constants/listPrices.ts","components/NoMatch.tsx","actions/uploadActions.ts","constants/login.ts","actions/loginActions.ts","components/Login/LoginForm.tsx","components/Login.tsx","containers/Login.ts","routes/index.tsx","App.tsx","api/index.ts","reducers/login.ts","reducers/prices.ts","reducers/upload.ts","reducers/index.ts","configureStore.ts","serviceWorker.ts","index.tsx"],"names":["FetchPrices","type","constants","LoadFetchedPrices","data","FaildOnFetch","error","OnSearchTextUpdate","value","UpdateSelectedList","UpdateSelectedDate","LoadFetchedLists","LoadFetchedDates","LoadFetchedLastListDate","SUCCESSFUL_LIST_NAME_FETCH","SUCCESSFUL_DATES_FETCH","SUCCESSFUL_LAST_DATE_FETCH","INIT_LAST_DATE_FETCH","FAILED_FETCH","UPDATE_SELECTED_DATE","INIT_LIST_UPLOAD","LIST_UPLOAD_SUCCESSFUL","START_EDITING","STOP_EDITING","DELETE_LIST","DELETE_LIST_SUCCESSFUL","CLEAR_EDITING_DATE","LIST_TYPE_FETCHED","TOGGLE_NUEVA_PLANILLA","ActivityAndErrorIndicator","this","props","loaded","initAction","loading","className","style","width","height","color","message","children","React","INIT_FECTCH","SUCCESSFUL_PRICE_LIST_FETCH","UPDATE_SEARCH_TEXT","UPDATE_SELECTED_LIST","CLEAR_LOADED_STATE","NoMatch","FetchLastDates","UploadList","SuccessfulLoadedList","StartEditing","StopEditing","DeleteList","ListDeletedSuccessfuly","ClearEditingDate","ClearLoadedState","ListTypeFetched","ToggleNuevaPlanilla","REQUEST_LOGIN","LOGIN_SUCCESSFUL","LOGIN_FAILED","LOGOUT","LoginSuccesFul","payload","LoginFailed","LoginForm","onSubmit","event","preventDefault","form","FormData","currentTarget","login","for","name","id","Login","nothing","token","to","connect","loginToken","dispatch","actions","history","createBrowserHistory","SecuredRoutes","Secured","fallback","mapDispatchToProps","logout","exact","path","component","render","App","ApiTemplate","url","a","fetch","headers","response","ok","Error","statusText","json","fetchPrices","date","fetchLastListDate","fetchLastLists","fetchAllLists","fetchAllLoadedDates","fetchAllListType","cargarLista","body","method","requestLogin","eliminarLista","lista","JSON","stringify","initialState","loginApi","Cmd","run","args","failActionCreator","successActionCreator","state","action","loop","allListOptions","datesLoaded","prices","searchText","selectOptions","selectedDate","fecha","selectedList","loadPrices","loadLastListDate","loadListByDate","list","batch","filter","lists","map","row","addingNewDate","allLoadedLists","filteredLists","listTypeOptions","listsDateOptions","nuevaPlanilla","loadAllListNames","loadAllDatesOptions","deleteList","initUpload","fecthListTypes","upload","none","rootReducer","combineReducers","enhancedCreateStore","createStore","isLocalhost","Boolean","window","location","hostname","match","registerValidSW","swUrl","config","navigator","serviceWorker","register","then","registration","onupdatefound","installingWorker","installing","onstatechange","controller","console","log","onUpdate","onSuccess","catch","store","preloadedState","composeEnhancer","__REDUX_DEVTOOLS_EXTENSION_COMPOSE__","compose","createRootReducer","install","applyMiddleware","configureStore","ReactDOM","document","getElementById","URL","process","href","origin","addEventListener","contentType","get","status","indexOf","ready","unregister","reload","checkValidServiceWorker"],"mappings":"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","file":"static/js/main.c617f848.chunk.js","sourcesContent":["import * as constants from '../constants/listPrices';\nimport { IDateOfList, ILoadedList, IPriceRow } from '../types';\n\n// List of prices events\nexport interface InitPriceFetch {\n    type: constants.INIT_FECTCH;\n}\n\nexport interface ISuccessfulPriceFetched {\n    type: constants.SUCCESSFUL_PRICE_LIST_FETCH;\n    data: IPriceRow[];\n}\n\nexport interface IFailOnFetch {\n    type: constants.FAILED_FETCH;\n    error: Error;\n}\n\nexport interface IUpdateSearchText {\n    type: constants.UPDATE_SEARCH_TEXT;\n    value: string;\n}\n\nexport interface ISuccessfulListsFectched {\n    type: constants.SUCCESSFUL_LIST_NAME_FETCH;\n    data: ILoadedList[];\n}\n\nexport interface IUpdateSelectedList {\n    type: constants.UPDATE_SELECTED_LIST;\n    value: string;\n}\n\nexport interface IUpdateSelectedDate {\n    type: constants.UPDATE_SELECTED_DATE;\n    value: IDateOfList;\n}\n\nexport interface ISuccessfulDatesFetched {\n    type: constants.SUCCESSFUL_DATES_FETCH;\n    data: IDateOfList[];\n}\n\nexport interface ISuccessfulLastListDateFetched {\n    type: constants.SUCCESSFUL_LAST_DATE_FETCH;\n    data: string;\n}\n\nexport interface IClearLoadedState {\n    type: constants.CLEAR_LOADED_STATE;\n}\n\nexport type PriceFetchAction = \n    | InitPriceFetch \n    | IClearLoadedState\n    | ISuccessfulPriceFetched \n    | IFailOnFetch \n    | IUpdateSearchText \n    | ISuccessfulListsFectched\n    | IUpdateSelectedList\n    | ISuccessfulDatesFetched\n    | ISuccessfulLastListDateFetched\n    | IUpdateSelectedDate;\n\n\nexport function FetchPrices(): PriceFetchAction {\n    return {\n        type: constants.INIT_FECTCH\n    }\n}\n\nexport function LoadFetchedPrices(data: IPriceRow[]): PriceFetchAction {\n    return {\n        data,\n        type: constants.SUCCESSFUL_PRICE_LIST_FETCH,\n        \n    }\n}\n\nexport function FaildOnFetch(error: Error): PriceFetchAction {\n    return {\n        error,\n        type: constants.FAILED_FETCH,\n    }\n}\n\nexport function OnSearchTextUpdate(value: string): PriceFetchAction {\n    return {\n        type: constants.UPDATE_SEARCH_TEXT,\n        value,\n    }\n}\n\nexport function UpdateSelectedList(value: string) : PriceFetchAction {\n    return {\n        type: constants.UPDATE_SELECTED_LIST,\n        value,\n    }\n}\n\nexport function UpdateSelectedDate(value: IDateOfList) : PriceFetchAction {\n    return {\n        type: constants.UPDATE_SELECTED_DATE,\n        value,\n    }\n}\n\nexport function LoadFetchedLists(data: ILoadedList[]) : PriceFetchAction {\n    return {\n        data,\n        type: constants.SUCCESSFUL_LIST_NAME_FETCH,\n    }\n}\n\nexport function LoadFetchedDates(data: IDateOfList[]) : PriceFetchAction {\n    return {\n        data,\n        type: constants.SUCCESSFUL_DATES_FETCH,\n    }\n}\n\nexport function LoadFetchedLastListDate(data:string) : PriceFetchAction {\n    return {\n        data,\n        type: constants.SUCCESSFUL_LAST_DATE_FETCH,\n    }\n}","export const SUCCESSFUL_PRICE_LIST_FETCH = '@@MANAGE_API/SUCCESSFUL_PRICE_LIST_FETCH';\nexport type SUCCESSFUL_PRICE_LIST_FETCH = typeof SUCCESSFUL_PRICE_LIST_FETCH;\n\nexport const SUCCESSFUL_LIST_NAME_FETCH = '@@MANAGE_API/SUCCESSFUL_LIST_NAME_FETCH';\nexport type SUCCESSFUL_LIST_NAME_FETCH = typeof SUCCESSFUL_LIST_NAME_FETCH;\n\nexport const SUCCESSFUL_DATES_FETCH = '@@MANAGE_API/SUCCESSFUL_DATES_FETCH';\nexport type SUCCESSFUL_DATES_FETCH = typeof SUCCESSFUL_DATES_FETCH;\n\nexport const SUCCESSFUL_LAST_DATE_FETCH = '@@MANAGE_API/SUCCESSFUL_LAST_DATE_FETCH';\nexport type SUCCESSFUL_LAST_DATE_FETCH = typeof SUCCESSFUL_LAST_DATE_FETCH;\n\nexport const INIT_LAST_DATE_FETCH = '@@MANAGE_API/INIT_LAST_DATE_FETCH';\nexport type INIT_LAST_DATE_FETCH = typeof INIT_LAST_DATE_FETCH;\n\nexport const FAILED_FETCH = '@@MANAGE_API/FAILED';\nexport type FAILED_FETCH = typeof FAILED_FETCH;\n\nexport const UPDATE_SEARCH_TEXT = '@@MANAGE_API/UPDATE_SEARCH_TEXT';\nexport type UPDATE_SEARCH_TEXT = typeof UPDATE_SEARCH_TEXT;\n\nexport const UPDATE_SELECTED_LIST = '@@MANAGE_API/UPDATE_SELECTED_LIST';\nexport type UPDATE_SELECTED_LIST = typeof UPDATE_SELECTED_LIST;\n\nexport const UPDATE_SELECTED_DATE = '@@MANAGE_API/UPDATE_SELECTED_DATE';\nexport type UPDATE_SELECTED_DATE = typeof UPDATE_SELECTED_DATE;\n\nexport const INIT_LIST_UPLOAD = '@@MANAGE_API/INIT_LIST_UPLOAD';\nexport type INIT_LIST_UPLOAD = typeof INIT_LIST_UPLOAD;\n\nexport const LIST_UPLOAD_SUCCESSFUL = '@@MANAGE_API/LIST_UPLOAD_SUCCESSFUL';\nexport type LIST_UPLOAD_SUCCESSFUL = typeof LIST_UPLOAD_SUCCESSFUL;\n\nexport const START_EDITING = '@@MANAGE_API/START_EDITING';\nexport type START_EDITING = typeof START_EDITING;\n\nexport const STOP_EDITING = '@@MANAGE_API/STOP_EDITING';\nexport type STOP_EDITING = typeof STOP_EDITING;\n\nexport const DELETE_LIST = '@@MANAGE_API/DELETE_LIST';\nexport type DELETE_LIST = typeof DELETE_LIST;\n\nexport const DELETE_LIST_SUCCESSFUL = '@@MANAGE_API/DELETE_LIST_SUCCESSFUL';\nexport type DELETE_LIST_SUCCESSFUL = typeof DELETE_LIST_SUCCESSFUL;\n\nexport const CLEAR_EDITING_DATE = '@@MANAGE_API/CLEAR_EDITING_DATE';\nexport type CLEAR_EDITING_DATE = typeof CLEAR_EDITING_DATE;\n\nexport const LIST_TYPE_FETCHED = '@@MANAGE_API/LIST_TYPE_FETCHED';\nexport type LIST_TYPE_FETCHED = typeof LIST_TYPE_FETCHED;\n\nexport const TOGGLE_NUEVA_PLANILLA = '@@MANAGE_API/TOGGLE_NUEVA_PLANILLA';\nexport type TOGGLE_NUEVA_PLANILLA = typeof TOGGLE_NUEVA_PLANILLA;","import * as React from 'react';\n// @ts-ignore\nimport { Alert, Spinner } from 'reactstrap';\n\n\ninterface IStateProps {\n    children: React.ReactNode;\n    loading: boolean;\n    error: Error | null;\n    loaded: boolean;\n}\n\ninterface IDispatchProps {\n    initAction: () => void;\n}\n\ntype IProps = IStateProps & IDispatchProps;\n\nexport class ActivityAndErrorIndicator extends React.Component<IProps> {\n    \n    componentDidMount() {\n        if(!this.props.loaded) {\n            this.props.initAction();\n        }\n    }\n\n    public render() {\n        if (this.props.loading) {\n            return <div className=\"loader\"><Spinner style={{ width: '30rem', height: '30rem' }} type=\"grow\" /></div>\n        }\n\n        if (this.props.error) {\n            return <Alert color=\"danger\"> Ha Ocurrido un error: {this.props.error.message} </Alert>\n        }\n\n        return this.props.children\n    }\n}","export const INIT_FECTCH = '@@PRICE_API/INIT_FETCH';\nexport type INIT_FECTCH = typeof INIT_FECTCH;\n\nexport const SUCCESSFUL_PRICE_LIST_FETCH = '@@PRICE_API/SUCCESSFUL_PRICE_LIST_FETCH';\nexport type SUCCESSFUL_PRICE_LIST_FETCH = typeof SUCCESSFUL_PRICE_LIST_FETCH;\n\nexport const SUCCESSFUL_LIST_NAME_FETCH = '@@PRICE_API/SUCCESSFUL_LIST_NAME_FETCH';\nexport type SUCCESSFUL_LIST_NAME_FETCH = typeof SUCCESSFUL_LIST_NAME_FETCH;\n\nexport const SUCCESSFUL_DATES_FETCH = '@@PRICE_API/SUCCESSFUL_DATES_FETCH';\nexport type SUCCESSFUL_DATES_FETCH = typeof SUCCESSFUL_DATES_FETCH;\n\nexport const SUCCESSFUL_LAST_DATE_FETCH = '@@PRICE_API/SUCCESSFUL_LAST_DATE_FETCH';\nexport type SUCCESSFUL_LAST_DATE_FETCH = typeof SUCCESSFUL_LAST_DATE_FETCH;\n\nexport const INIT_LAST_DATE_FETCH = '@@PRICE_API/INIT_LAST_DATE_FETCH';\nexport type INIT_LAST_DATE_FETCH = typeof INIT_LAST_DATE_FETCH;\n\nexport const FAILED_FETCH = '@@PRICE_API/FAILED';\nexport type FAILED_FETCH = typeof FAILED_FETCH;\n\nexport const UPDATE_SEARCH_TEXT = '@@PRICE_LIST/UPDATE_SEARCH_TEXT';\nexport type UPDATE_SEARCH_TEXT = typeof UPDATE_SEARCH_TEXT;\n\nexport const UPDATE_SELECTED_LIST = '@@PRICE_LIST/UPDATE_SELECTED_LIST';\nexport type UPDATE_SELECTED_LIST = typeof UPDATE_SELECTED_LIST;\n\nexport const UPDATE_SELECTED_DATE = '@@PRICE_LIST/UPDATE_SELECTED_DATE';\nexport type UPDATE_SELECTED_DATE = typeof UPDATE_SELECTED_DATE;\n\nexport const CLEAR_LOADED_STATE = '@@PRICE_LIST/CLEAR_LOADED_STATE';\nexport type CLEAR_LOADED_STATE = typeof CLEAR_LOADED_STATE;","import * as React from 'react'\n\nconst NoMatch = () => (\n    <div className=\"loader\">\n      La Pagina que estas buscando no existe\n    </div>\n  )\n  \n  export default NoMatch","import { CLEAR_LOADED_STATE } from \"../constants/listPrices\";\nimport * as constants from '../constants/manageLists';\n\n\nimport {\n    IDateOfList,\n    IDeleteListData,\n    ILoadedList,\n    ILoadList\n    } from '../types/index';\n\nexport interface InitLastDateFetch {\n    type: constants.INIT_LAST_DATE_FETCH;\n}\nexport interface IFailOnFetch {\n    type: constants.FAILED_FETCH;\n    error: Error;\n}\nexport interface ISuccessfulListsFectched {\n    type: constants.SUCCESSFUL_LIST_NAME_FETCH;\n    data: ILoadedList[];\n}\nexport interface IUpdateSelectedDate {\n    type: constants.UPDATE_SELECTED_DATE;\n    value: IDateOfList;\n}\n\nexport interface ISuccessfulDatesFetched {\n    type: constants.SUCCESSFUL_DATES_FETCH;\n    data: IDateOfList[];\n}\n\nexport interface ISuccessfulLastListDateFetched {\n    type: constants.SUCCESSFUL_LAST_DATE_FETCH;\n    data: string;\n}\n\nexport interface InitListUpload {\n    type: constants.INIT_LIST_UPLOAD;\n    data: FormData;\n}\n\nexport interface ISuccessfulListUpload {\n    type: constants.LIST_UPLOAD_SUCCESSFUL;\n    data: ILoadList\n}\n\nexport interface IStartEditing {\n    type: constants.START_EDITING;\n}\n\nexport interface IStopEditing {\n    type: constants.STOP_EDITING;\n}\n\nexport interface IDeleteList {\n    type: constants.DELETE_LIST;\n    value: IDeleteListData;\n}\n\nexport interface IListDeletedSuccessfuly {\n    type: constants.DELETE_LIST_SUCCESSFUL;\n}\n\nexport interface IClearEditingDate {\n    type: constants.CLEAR_EDITING_DATE;\n}\n\nexport interface IClearLoadedState {\n    type: CLEAR_LOADED_STATE;\n}\n\nexport interface IListTypeFetched {\n    data: string[];\n    type: constants.LIST_TYPE_FETCHED;\n}\n\nexport interface IToggleNuevaPlanilla {\n    type: constants.TOGGLE_NUEVA_PLANILLA;\n}\n\nexport type UploadListAction = \n    | InitLastDateFetch\n    | IClearLoadedState\n    | ISuccessfulLastListDateFetched\n    | IFailOnFetch\n    | IUpdateSelectedDate\n    | ISuccessfulListsFectched\n    | ISuccessfulDatesFetched\n    | InitListUpload\n    | ISuccessfulListUpload\n    | IStartEditing\n    | IStopEditing\n    | IDeleteList\n    | IListDeletedSuccessfuly\n    | IClearEditingDate\n    | IListTypeFetched\n    | IToggleNuevaPlanilla;\n\nexport function FetchLastDates (): UploadListAction {\n    return {\n        type: constants.INIT_LAST_DATE_FETCH\n    }\n}\n\nexport function UploadList(data: FormData): UploadListAction {\n    return {\n        data,\n        type: constants.INIT_LIST_UPLOAD,\n        \n    }\n}\n\nexport function SuccessfulLoadedList(data: ILoadList): UploadListAction {\n    return {\n        data,\n        type: constants.LIST_UPLOAD_SUCCESSFUL,\n    }\n}\n\nexport function FaildOnFetch(error: Error): UploadListAction {\n    return {\n        error,\n        type: constants.FAILED_FETCH,\n    }\n}\n\nexport function LoadFetchedLists(data: ILoadedList[]): UploadListAction {\n    return {\n        data,\n        type: constants.SUCCESSFUL_LIST_NAME_FETCH,   \n    }\n}\n\nexport function LoadFetchedDates(data: IDateOfList[]): UploadListAction {\n    return {\n        data,\n        type: constants.SUCCESSFUL_DATES_FETCH,\n    }\n}\n\nexport function LoadFetchedLastListDate(data:string): UploadListAction {\n    return {\n        data,\n        type: constants.SUCCESSFUL_LAST_DATE_FETCH,\n    }\n}\n\nexport function UpdateSelectedDate(value: IDateOfList) : UploadListAction {\n    return {\n        type: constants.UPDATE_SELECTED_DATE,\n        value,\n    }\n}\n\nexport function StartEditing() : UploadListAction {\n    return {\n        type: constants.START_EDITING\n    }\n}\n\nexport function StopEditing() : UploadListAction {\n    return {\n        type: constants.STOP_EDITING\n    }\n}\n\nexport function DeleteList(value: IDeleteListData) : UploadListAction {\n    return {\n        type: constants.DELETE_LIST,\n        value\n    }\n}\n\nexport function ListDeletedSuccessfuly() : UploadListAction {\n    return {\n        type: constants.DELETE_LIST_SUCCESSFUL,\n    }\n}\n\nexport function ClearEditingDate() : UploadListAction {\n    return {\n        type: constants.CLEAR_EDITING_DATE,\n    }\n}\n\nexport function ClearLoadedState() : UploadListAction {\n    return {\n        type: CLEAR_LOADED_STATE,\n    }\n}\n\nexport function ListTypeFetched(data: string[]) : UploadListAction {\n    return {\n        data,\n        type: constants.LIST_TYPE_FETCHED,\n    }\n}\n\nexport function ToggleNuevaPlanilla() : UploadListAction {\n    return {\n        type: constants.TOGGLE_NUEVA_PLANILLA,\n    }\n}\n","export const REQUEST_LOGIN = '@@LOGIN_API/REQUEST_LOGIN';\nexport type REQUEST_LOGIN = typeof REQUEST_LOGIN;\n\nexport const LOGIN_SUCCESSFUL = '@@LOGIN_API/LOGIN_SUCCESSFUL';\nexport type LOGIN_SUCCESSFUL = typeof LOGIN_SUCCESSFUL;\n\nexport const LOGIN_FAILED = '@@LOGIN_API/LOGIN_FAILED';\nexport type LOGIN_FAILED = typeof LOGIN_FAILED;\n\nexport const LOGOUT = '@@LOGIN_API/LOGOUT';\nexport type LOGOUT = typeof LOGOUT;\n\n\n","import * as constants from \"../constants/login\";\n\nimport { IToken } from \"../types/index\";\n\nexport interface IRequestLogin {\n  payload: FormData;\n  type: constants.REQUEST_LOGIN;\n}\nexport interface ILoginSuccessful {\n  payload: IToken;\n  type: constants.LOGIN_SUCCESSFUL;\n}\nexport interface ILoginFailed {\n  payload: Error;\n  type: constants.LOGIN_FAILED;\n}\n\nexport interface ILogout {\n  type: constants.LOGOUT\n}\n\nexport type LoginAction = IRequestLogin | ILoginFailed | ILoginSuccessful | ILogout;\n\nexport function RequestLogin(data: FormData): LoginAction {\n  return {\n    payload: data,\n    type: constants.REQUEST_LOGIN\n  };\n}\n\nexport function LoginSuccesFul(data: IToken): LoginAction {\n  return {\n    payload: data,\n    type: constants.LOGIN_SUCCESSFUL\n  };\n}\n\nexport function LoginFailed(error: Error): LoginAction {\n  return {\n    payload: error,\n    type: constants.LOGIN_FAILED\n  };\n}\n\nexport function Logout(): LoginAction {\n  return {\n    type: constants.LOGOUT\n  }\n}\n","import * as React from \"react\";\nimport Button from \"reactstrap/lib/Button\";\nimport Card from \"reactstrap/lib/Card\";\nimport CardBody from \"reactstrap/lib/CardBody\";\nimport CardFooter from \"reactstrap/lib/CardFooter\";\nimport CardHeader from \"reactstrap/lib/CardHeader\";\nimport Form from \"reactstrap/lib/Form\";\nimport FormGroup from \"reactstrap/lib/FormGroup\";\nimport Input from \"reactstrap/lib/Input\";\nimport Label from \"reactstrap/lib/Label\";\nimport Alert from \"reactstrap/lib/Alert\";\nimport Container from \"reactstrap/lib/Container\";\nimport Row from \"reactstrap/lib/Row\";\nimport Col from \"reactstrap/lib/Col\";\n\ninterface IDataProps {\n  error: Error | null;\n  loading: boolean;\n}\n\ninterface IDispatchProps {\n  login: (form: FormData) => void;\n}\n\ntype IProps = IDataProps & IDispatchProps;\n\nfunction LoginForm(props: IProps) {\n  const loginAction = (event: any) => {\n    event.preventDefault();\n    const form = new FormData(event.currentTarget);\n    props.login(form);\n  };\n\n  return (\n    <Container>\n      <Row>\n        <Col className=\"login col-sm-9 col-md-7 col-lg-5 mx-auto\">\n          <Card className=\"border-primary\">\n            <CardHeader>\n              <h4>Login Libreria Alvarez</h4>\n            </CardHeader>\n            <Form onSubmit={loginAction}>\n              <CardBody>\n                <FormGroup>\n                  <Label for=\"username\">Nombre de Usuario:</Label>\n                  <Input type=\"text\" name=\"username\" id=\"username\" />\n                </FormGroup>\n                <FormGroup>\n                  <Label for=\"password\">Contraseña:</Label>\n                  <Input type=\"password\" name=\"password\" id=\"password\" />\n                </FormGroup>\n              </CardBody>\n              <CardFooter>\n                <Button color=\"primary\">Login</Button>\n                {\"  \"}\n              </CardFooter>\n            </Form>\n          </Card>\n          {props.error && (\n            <Alert color=\"danger\">Error: {props.error.message}</Alert>\n          )}\n        </Col>\n      </Row>\n    </Container>\n  );\n}\n\nexport default LoginForm;\n","import * as React from 'react';\nimport LoginForm from './Login/LoginForm';\nimport { IToken } from '../types';\nimport { Redirect } from 'react-router';\nimport { ActivityAndErrorIndicator } from './commons/ActivityAndErrorIndicator';\n\ninterface IStateProps {\n    loading: boolean;\n    error: Error | null;\n    token: IToken | null;\n}\n\ninterface IDispatchProps {\n    login: (data: FormData) => void;\n}\n\ntype IProps = IStateProps & IDispatchProps;\n\nclass Login extends React.Component<IProps, {}> {\n\n    private nothing: () => void = () => {};\n    \n    public render() {\n        if (this.props.token) {\n            return <Redirect to='/users' />\n        }\n\n        return (\n            <ActivityAndErrorIndicator initAction={this.nothing} loading={this.props.loading} error={null} loaded={true} >\n                <LoginForm error={this.props.error} loading={this.props.loading} login={this.props.login} />\n            </ActivityAndErrorIndicator>\n            );\n    }\n}\n\nexport default Login;","import { connect } from 'react-redux';\nimport { Dispatch } from 'redux';\nimport { LoginAction } from '../actions';\nimport * as actions from '../actions/loginActions';\nimport Login from '../components/Login';\nimport { IStoreState } from '../types';\n\nexport function mapStateToProps({ login } : IStoreState) {\n    return {\n        error: login.error,\n        loading: login.loading,\n        token: login.loginToken,\n    }\n}\n\nexport function mapDispatchToProps(dispatch: Dispatch<LoginAction>) {\n    return {\n        login: (data: FormData) => dispatch(actions.RequestLogin(data)),\n    }\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(Login);\n","import * as React from \"react\";\nimport { Route, Switch, Router } from \"react-router\";\nimport NoMatch from \"../components/NoMatch\";\nimport { IRoutesProps, IStoreState, ILoginState } from \"../types\";\nimport Login from \"../containers/Login\";\nimport { Redirect } from \"react-router-dom\";\nimport { connect } from \"react-redux\";\nimport { createBrowserHistory } from \"history\";\nimport { Logout } from \"../actions/loginActions\";\n\nconst history = createBrowserHistory();\n\nconst SecuredRoutes = React.lazy(() => import(\"./secured\"));\nconst Secured = (props: IRoutesProps) => (\n  <React.Suspense\n    fallback={\n      <div>\n        <p>\n          <em>Cargando...</em>\n        </p>\n      </div>\n    }\n  >\n    <SecuredRoutes {...props} />\n  </React.Suspense>\n);\n\nconst mapStateToProps = ({ login }: IStoreState) => {\n  return {\n    login\n  };\n};\n\nconst mapDispatchToProps = {\n  logout: Logout\n};\n\ninterface IProps {\n  login: ILoginState;\n  logout: () => void;\n}\n\nconst Routes = (props: IProps) => (\n  <Router history={history}>\n    <Switch>\n      <Route\n        exact={true}\n        path=\"/\"\n        component={() => {\n          if (props.login.loginToken === null) {\n            return <Login />;\n          }\n          return <Redirect to=\"/users\" />;\n        }}\n      />\n      <Route\n        exact\n        path=\"/users/logout\"\n        component={() => {\n          props.logout();\n          return <Redirect to=\"/\" />;\n        }}\n      />\n      <Route path=\"/users\" render={Secured} />\n      <Route component={NoMatch} />\n    </Switch>\n  </Router>\n);\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(Routes);\n","import 'bootstrap/dist/css/bootstrap.css';\nimport 'open-iconic/font/css/open-iconic-bootstrap.min.css';\nimport * as React from 'react';\nimport Routes from './routes';\nimport './styles/App.css';\n\n\ninterface IAppProps {\n    history: History;\n}\n\nclass App extends React.Component {\n    public render() {\n        return (\n                <Routes />\n        );\n    }\n}\n\nexport default App;\n","import {\n    IDateOfList,\n    IDeleteListData,\n    ILoadedList,\n    ILoadList,\n    IPriceRow,\n    IToken\n} from '../types';\n\nasync function ApiTemplate<T>(url: string): Promise<T> {\n    const response = await fetch(url, {\n        headers: {\n            'Authentication': 'adasdasfasfsafsafasds',\n            'Accept': 'application/json',\n            'Content-Type': 'application/json',\n        }\n    });\n    if (!response.ok) {\n        throw new Error(response.statusText);\n    }\n    return await response.json();\n}\n\nexport async function fetchPrices(date: string): Promise<IPriceRow[]> {\n    return await ApiTemplate<IPriceRow[]>('/api/prices-by-fecha?fecha=' + date);\n}\n\nexport async function fetchLastListDate(): Promise<string> {\n    return await ApiTemplate<string>('/api/get-last-date');\n}\n\nexport async function fetchLastLists(date: string): Promise<IPriceRow[]> {\n    return await fetchPrices(date);\n}\n\nexport function fetchAllLists(): Promise<ILoadedList[]> {\n    return ApiTemplate<ILoadedList[]>('/api/get-all-loaded-lists');\n}\n\nexport function fetchAllLoadedDates(): Promise<IDateOfList[]> {\n    return ApiTemplate<IDateOfList[]>('/api/get-all-dates');\n}\n\nexport function fetchAllListType(): Promise<string[]> {\n    return ApiTemplate<string[]>('/api/get-list-types');\n}\n\nexport async function cargarLista(form: FormData): Promise<ILoadList> {\n    const response = await fetch('/api/cargar-lista', {\n        body: form,\n        method: 'POST'\n    });\n\n    if (!response.ok) {\n        throw new Error(response.statusText);\n    }\n\n    return await response.json();\n}\n\n\nexport async function requestLogin(form: FormData): Promise<IToken> {\n    const response = await fetch('/api/login', {\n        body: form,\n        method: 'POST'\n    });\n\n    if (!response.ok) {\n        throw new Error(response.statusText);\n    }\n\n    return await response.json();\n}\n\nexport async function eliminarLista(lista: IDeleteListData): Promise<number> {\n    const response = await fetch('/api/delete-list-by-date-and-name', {\n        body: JSON.stringify(lista),\n        headers: { 'Content-type': 'application/json' },\n        method: 'POST',\n    });\n\n    if (!response.ok) {\n        throw new Error(response.statusText);\n    }\n\n    return await response.json();\n}","import { Cmd, loop, Loop, LoopReducer, RunCmd } from \"redux-loop\";\nimport { requestLogin } from \"../api\";\nimport * as constants from \"../constants/login\";\nimport { ILoginState } from \"../types/index\";\nimport { LoginAction } from \"../actions\";\nimport { LoginSuccesFul, LoginFailed } from \"../actions/loginActions\";\n\nconst initialState: ILoginState = {\n  error: null,\n  loading: false,\n  loginToken: null\n};\n\nconst loginApi: (data: FormData) => RunCmd<LoginAction> = (data: FormData) =>\n  Cmd.run(requestLogin, {\n    args: [data],\n    failActionCreator: LoginFailed,\n    successActionCreator: LoginSuccesFul\n  });\n\nexport const login: LoopReducer<ILoginState, LoginAction> = (\n  state: ILoginState = initialState,\n  action: LoginAction | any\n): ILoginState | Loop<ILoginState, LoginAction> => {\n  switch (action.type) {\n    case constants.REQUEST_LOGIN:\n      return loop(\n        {\n          ...state,\n          error: null,\n          loading: true\n        },\n        loginApi(action.payload)\n      );\n    case constants.LOGIN_SUCCESSFUL:\n      return {\n        error: null,\n        loading: false,\n        loginToken: action.payload\n      };\n    case constants.LOGIN_FAILED:\n      return {\n        error: action.payload,\n        loading: false,\n        loginToken: null\n      };\n    case constants.LOGOUT:\n      return initialState;\n    default:\n      return state;\n  }\n};\n","import {\n    Cmd,\n    ListCmd,\n    loop,\n    Loop,\n    LoopReducer,\n    RunCmd\n    } from 'redux-loop';\nimport { PriceFetchAction } from '../actions';\nimport {\n    FaildOnFetch,\n    LoadFetchedDates,\n    LoadFetchedLastListDate,\n    LoadFetchedLists,\n    LoadFetchedPrices\n    } from '../actions/listPrices';\nimport * as constants from '../constants/listPrices';\nimport { IPricesState } from '../types/index';\nimport {\n    fetchAllLists,\n    fetchAllLoadedDates,\n    fetchLastListDate,\n    fetchLastLists\n    } from '../api';\n\nconst initialState: IPricesState = {\n    allListOptions: [],\n    datesLoaded: [], \n    error: null,\n    loaded: false,\n    loading: false,\n    prices: [],\n    searchText: \"\",\n    selectOptions: [],\n    selectedDate: { fecha: \"\" },\n    selectedList: \"\",\n}\n\nconst loadPrices: (date: string) => RunCmd<PriceFetchAction> =\n    (date: string) => Cmd.run(fetchLastLists, {\n        args: [date],\n        failActionCreator: FaildOnFetch,\n        successActionCreator: LoadFetchedPrices,\n\n    });\n\nconst loadLists: () => RunCmd<PriceFetchAction> =\n    () => Cmd.run(fetchAllLists, {\n        failActionCreator: FaildOnFetch,\n        successActionCreator: LoadFetchedLists,\n    });\n\nconst loadDates: () => RunCmd<PriceFetchAction> =\n    () => Cmd.run(fetchAllLoadedDates, {\n        failActionCreator: FaildOnFetch,\n        successActionCreator: LoadFetchedDates,\n    });\n\nconst loadLastListDate: () => RunCmd<PriceFetchAction> =\n    () => Cmd.run(fetchLastListDate, {\n        failActionCreator: FaildOnFetch,\n        successActionCreator: LoadFetchedLastListDate,\n    });\n\nconst loadListByDate: (date: string) => ListCmd<PriceFetchAction> =\n    (date: string) => Cmd.list([loadPrices(date), loadLists(), loadDates()], {\n        batch: true\n    });\n\nexport const prices: LoopReducer<IPricesState, PriceFetchAction> =\n    (state: IPricesState = initialState, action: PriceFetchAction): IPricesState | Loop<IPricesState, PriceFetchAction> => {\n        switch (action.type) {\n            case constants.INIT_FECTCH:\n                return loop(\n                    { ...state, \n                        error: null, \n                        loading: true },\n                    loadLastListDate());\n            case constants.SUCCESSFUL_PRICE_LIST_FETCH:\n                return {\n                    ...state,\n                    loaded: true,\n                    loading: false,\n                    prices: action.data,\n                };\n            case constants.CLEAR_LOADED_STATE:\n                return initialState;\n            case constants.SUCCESSFUL_LIST_NAME_FETCH:\n                return {\n                    ...state,\n                    allListOptions: action.data,\n                    loading: false,\n                    selectOptions: action.data\n                        .filter(lists => lists.fecha === state.selectedDate.fecha)\n                        .map(row => row.lista),\n                };\n            case constants.SUCCESSFUL_LAST_DATE_FETCH:\n                return loop({\n                    ...state,\n                    selectedDate: { fecha: action.data },\n                }, loadListByDate(action.data));\n            case constants.SUCCESSFUL_DATES_FETCH:\n                return {\n                    ...state,\n                    datesLoaded: action.data,\n                };\n            case constants.FAILED_FETCH:\n                return { ...state, error: action.error, loading: false };\n            case constants.UPDATE_SEARCH_TEXT:\n                return {\n                    ...state,\n                    searchText: action.value\n                };\n            case constants.UPDATE_SELECTED_LIST:\n                return {\n                    ...state,\n                    selectedList: action.value\n                };\n            case constants.UPDATE_SELECTED_DATE:\n                return loop({\n                    ...state,\n                    loading: true,\n                    selectOptions: state.allListOptions\n                        .filter(lists => lists.fecha === action.value.fecha)\n                        .map(row => row.lista),\n                    selectedDate: action.value,\n                    selectedList: \"\",\n                }, loadPrices(action.value.fecha))\n            default: return state;\n        }\n    }\n","import {\n    Cmd,\n    loop,\n    Loop,\n    LoopReducer,\n    RunCmd\n    } from 'redux-loop';\nimport {\n    ClearLoadedState,\n    FaildOnFetch,\n    ListDeletedSuccessfuly,\n    ListTypeFetched,\n    LoadFetchedDates,\n    LoadFetchedLastListDate,\n    LoadFetchedLists,\n    StopEditing,\n    SuccessfulLoadedList,\n    ToggleNuevaPlanilla,\n    UpdateSelectedDate,\n    UploadListAction\n    } from '../actions/uploadActions';\nimport {\n    cargarLista,\n    eliminarLista,\n    fetchAllLists,\n    fetchAllListType,\n    fetchAllLoadedDates,\n    fetchLastListDate\n    } from '../api';\nimport * as constants from '../constants/manageLists';\nimport { IDeleteListData, IManageUploadState } from '../types/index';\n\nconst initialState: IManageUploadState = {\n    addingNewDate: false,\n    allLoadedLists: [],\n    error: null,\n    filteredLists: [],\n    listTypeOptions: [],\n    listsDateOptions: [],\n    loading: true,\n    nuevaPlanilla: false,\n    selectedDate: { fecha: \"\" },\n}\n\nconst loadLastListDate: () => RunCmd<UploadListAction> =\n    () => Cmd.run(fetchLastListDate, {\n        failActionCreator: FaildOnFetch,\n        successActionCreator: LoadFetchedLastListDate,\n    });\n\nconst loadAllListNames: () => RunCmd<UploadListAction> =\n    () => Cmd.run(fetchAllLists, {\n        failActionCreator: FaildOnFetch,\n        successActionCreator: LoadFetchedLists,\n    });\n\nconst loadAllDatesOptions: () => RunCmd<UploadListAction> =\n    () => Cmd.run(fetchAllLoadedDates, {\n        failActionCreator: FaildOnFetch,\n        successActionCreator: LoadFetchedDates,\n    });\n\nconst deleteList: (list: IDeleteListData) => RunCmd<UploadListAction> =\n    (list: IDeleteListData) => Cmd.run(eliminarLista, {\n        args: [list],\n        failActionCreator: FaildOnFetch,\n        successActionCreator: ListDeletedSuccessfuly,\n    });\n\nconst initUpload: (data: FormData) => RunCmd<UploadListAction> =\n    (data: FormData) => Cmd.run(cargarLista, {\n        args: [data],\n        failActionCreator: FaildOnFetch,\n        successActionCreator: SuccessfulLoadedList,\n    });\n\nconst fecthListTypes: () => RunCmd<UploadListAction> =\n    () => Cmd.run(fetchAllListType, {\n        failActionCreator: FaildOnFetch,\n        successActionCreator: ListTypeFetched,\n    });\n\n\nexport const upload: LoopReducer<IManageUploadState, UploadListAction> =\n    (state: IManageUploadState = initialState, action: UploadListAction): IManageUploadState | Loop<IManageUploadState, UploadListAction> => {\n        switch (action.type) {\n            case constants.INIT_LAST_DATE_FETCH:\n                return loop(\n                    {\n                        ...state,\n                        error: null ,\n                        loading: true\n                    }, Cmd.list(\n                        [\n                            loadLastListDate(), \n                            loadAllListNames(), \n                            loadAllDatesOptions(), \n                            fecthListTypes()\n                        ], {\n                            batch: true\n                    })\n                );\n            case constants.SUCCESSFUL_LIST_NAME_FETCH:\n                return {\n                    ...state,\n                    allLoadedLists: action.data,\n                    filteredLists: action.data\n                        .filter(lists => lists.fecha === state.selectedDate.fecha),\n                    loading: false\n                };\n            case constants.SUCCESSFUL_DATES_FETCH:\n                return {\n                    ...state,\n                    listsDateOptions: action.data\n                }\n            case constants.SUCCESSFUL_LAST_DATE_FETCH:\n                return loop({\n                    ...state,\n                    selectedDate: { fecha: action.data },\n                }, Cmd.action(UpdateSelectedDate({fecha: action.data})));\n            case constants.FAILED_FETCH:\n                return { ...state, error: action.error, loading: false };\n            case constants.UPDATE_SELECTED_DATE:\n                return loop({\n                    ...state,\n                    filteredLists: state.allLoadedLists\n                        .filter(lists => lists.fecha === action.value.fecha),\n                    selectedDate: action.value,\n                }, Cmd.none)\n            case constants.INIT_LIST_UPLOAD:\n                return loop({\n                    ...state,\n                    loading: true,\n                }, initUpload(action.data));\n            case constants.LIST_UPLOAD_SUCCESSFUL:\n                return loop({\n                    ...state,\n                    loading: false,\n                }, Cmd.list(\n                    [\n                        loadAllListNames(), \n                        loadAllDatesOptions(), \n                        Cmd.action(ClearLoadedState()), \n                        Cmd.action(StopEditing()), \n                        Cmd.action(ToggleNuevaPlanilla())\n                    ], {\n                        batch: true\n                }));\n            case constants.START_EDITING:\n                return {\n                    ...state,\n                    addingNewDate: true,\n                }\n            case constants.STOP_EDITING:\n                return loop({\n                    ...state,\n                    addingNewDate: false,\n                }, Cmd.none)\n            case constants.CLEAR_EDITING_DATE:\n                return loop({\n                    ...state,\n                    addingNewDate: false,\n                }, loadLastListDate())\n            case constants.DELETE_LIST:\n                return loop({\n                    ...state,\n                    loading: true\n                }, deleteList(action.value))\n            case constants.DELETE_LIST_SUCCESSFUL:\n                return loop({\n                    ...state,\n                    loading: false\n                }, Cmd.list(\n                    [\n                        loadAllListNames(), \n                        loadAllDatesOptions(), \n                        Cmd.action(ClearLoadedState())\n                    ], {\n                        batch: true\n                    }));\n            case constants.LIST_TYPE_FETCHED:\n                return {\n                    ...state,\n                    listTypeOptions: action.data,\n                }\n            case constants.TOGGLE_NUEVA_PLANILLA:\n                return {\n                    ...state,\n                    nuevaPlanilla: !state.nuevaPlanilla\n                }\n            default: return state;\n        }\n    }\n","import { combineReducers, LoopReducer } from \"redux-loop\";\nimport { login } from \"./login\";\nimport { PriceFetchAction, UploadListAction, LoginAction } from \"../actions\";\nimport {\n  IManageUploadState,\n  IPricesState,\n  IStoreState,\n  ILoginState\n} from \"../types\";\nimport { prices } from \"./prices\";\nimport { upload } from \"./upload\";\n\nconst rootReducer = () =>\n  combineReducers<\n    | IStoreState\n    | LoopReducer<IPricesState, PriceFetchAction>\n    | LoopReducer<IManageUploadState, UploadListAction>\n    | LoopReducer<ILoginState, LoginAction>\n  >({\n    prices,\n    upload,\n    login\n  });\n\nexport default rootReducer;\n","import { applyMiddleware, compose, createStore } from 'redux';\nimport { install, StoreCreator } from 'redux-loop';\nimport createRootReducer from './reducers';\n\nconst enhancedCreateStore = createStore as StoreCreator;\n\nexport default function configureStore(preloadedState?: any) {\n  const composeEnhancer: typeof compose = (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose\n\n  const store = enhancedCreateStore(\n    createRootReducer(),\n    preloadedState,\n    composeEnhancer(\n      install(), \n      applyMiddleware(\n        \n      ),\n    ),\n  )\n  return store\n}","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\nimport App from './App';\nimport configureStore from './configureStore';\nimport * as serviceWorker from './serviceWorker';\n\nconst store = configureStore();\n\nReactDOM.render(\n    <Provider store={store}>\n        <App />\n    </Provider>, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.register();\n "],"sourceRoot":""}